#
# This file is part of gtkD.
# 
# gtkD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version, with
# some exceptions, please read the COPYING file.
# 
# gtkD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public License
# along with gtkD; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110, USA
#


#
###
#####
# Definitions for wrapping GObject
#####
###
#


addTypedefs: start

public import gtkc.glibtypes;
public import gtkc.gobjecttypes;

addTypedefs: end

addAliases: start
addAliases: end

addEnums: start

enum GResolverRecordType
{
	SRV = 1,
	MX,
	TXT,
	SOA,
	NS
}
alias GResolverRecordType ResolverRecordType;

addEnums: end

addStructs: start

struct GStaticResource
{
	guint8* data;
	gsize   data_len;
	GResource* resource;
	GStaticResource* next;
	gpointer padding;
}

addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start
addConstants: end

# must start with wrap
wrap: gio

###########################################################
### File Operations #######################################
###########################################################

file: GFile.html
struct: GFile
class: File
extend: GObject
prefix: g_file_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AppInfo
import: gio.AppInfoIF
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.FileAttributeInfoList
import: gio.FileEnumerator
import: gio.FileInfo
import: gio.FileInputStream
import: gio.FileIOStream
import: gio.FileMonitor
import: gio.FileOutputStream
import: gio.Icon
import: gio.IconIF
import: gio.Mount
import: gio.MountIF
import: gio.MountOperation
structWrap: GAppInfo* AppInfoIF
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFile* File
structWrap: GFileAttributeInfoList* FileAttributeInfoList
structWrap: GFileEnumerator* FileEnumerator
structWrap: GFileInfo* FileInfo
structWrap: GFileInputStream* FileInputStream
structWrap: GFileIOStream* FileIOStream
structWrap: GFileMonitor* FileMonitor
structWrap: GFileOutputStream* FileOutputStream
structWrap: GIcon* IconIF
structWrap: GMount* MountIF
structWrap: GMountOperation* MountOperation

out: g_file_set_attributes_finish info
out: g_file_load_contents contents
out: g_file_load_contents length
out: g_file_load_contents etag_out
out: g_file_load_contents_finish contents
out: g_file_load_contents_finish length
out: g_file_load_contents_finish etag_out
out: g_file_load_partial_contents_finish contents
out: g_file_load_partial_contents_finish  length
out: g_file_load_partial_contents_finish etag_out
out: g_file_replace_contents new_etag
out: g_file_replace_contents_finish new_etag
out: g_file_new_tmp iostream

# g_file_new_for_commandline_arg also accepts paths ans uris
nocode: g_file_new_for_path
nocode: g_file_new_for_uri
outFile: File


file: gio-GFileAttribute.html
struct: GFileAttributeInfoList
class: FileAttributeInfoList
prefix: g_file_attribute_info_list_
import: glib.Str
structWrap: GFileAttributeInfoList* FileAttributeInfoList
outFile: FileAttributeInfoList

file: GFileInfo.html
struct: GFileInfo
class: FileInfo
extend: GObject
prefix: g_file_info_
noprefix: g_file_attribute_matcher_
import: glib.Str
import: glib.DateTime
import: gobject.ObjectG
import: gio.Icon
import: gio.IconIF
import: gio.FileAttributeMatcher
structWrap: GDateTime* DateTime
structWrap: GObject* ObjectG
structWrap: GIcon* IconIF
structWrap: GFileAttributeMatcher* FileAttributeMatcher
structWrap: GFileInfo* FileInfo

out: g_file_info_get_attribute_data type
out: g_file_info_get_attribute_data value_pp
out: g_file_info_get_attribute_data status
array: g_file_info_set_attribute_stringv attr_value
out: g_file_info_get_modification_time result
inout: g_file_info_set_modification_time mtime

outFile: FileInfo


struct: GFileAttributeMatcher
class: FileAttributeMatcher
prefix: g_file_attribute_matcher_
strictPrefix: Y
import: glib.Str
structWrap: GFileAttributeMatcher* FileAttributeMatcher
override: toString
outFile: FileAttributeMatcher

file: GFileEnumerator.html
struct: GFileEnumerator
class: FileEnumerator
prefix: g_file_enumerator_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.File
import: gio.FileInfo
structWrap: GList* ListG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFile* File
structWrap: GFileInfo* FileInfo
outFile: FileEnumerator

file: gio-GIOError.html
class: ErrorGIO
prefix: g_io_error_
outFile: ErrorGIO

file: GMountOperation.html
struct: GMountOperation
class: MountOperation
extend: GObject
prefix: g_mount_operation_
import: glib.Str
import: glib.ArrayG
structWrap: GArray* ArrayG
outFile: MountOperation

###########################################################
### File System Monitoring ################################
###########################################################

file: GFileMonitor.html
struct: GFileMonitor
class: FileMonitor
extend: GObject
prefix: g_file_monitor_
import: gio.File
structWrap: GFile* File
outFile: FileMonitor

###########################################################
### File-related Utilities ################################
###########################################################

file: GFilenameCompleter.html
struct: GFilenameCompleter
class: FilenameCompleter
prefix: g_filename_completer_
import: glib.Str
outFile: FilenameCompleter

###########################################################
### Asynchronous I/O ######################################
###########################################################

file: GCancellable.html
struct: GCancellable
class: Cancellable
prefix: g_cancellable_
import: glib.ErrorG
import: glib.GException
import: glib.Source
structWrap: GCancellable* Cancellable
structWrap: GSource* Source
outFile: Cancellable

file: GAsyncResult.html
struct: GAsyncResult
class: AsyncResultT
template: TStruct
prefix: g_async_result_
import: gobject.ObjectG
import: glib.ErrorG
import: glib.GException
structWrap: GObject* ObjectG
interface: AsyncResultIF
outFile: AsyncResultT

file: GTask.html
struct: GTask
class: Task
implements: AsyncResultIF
prefix: g_task_
import: glib.ErrorG
import: glib.GException
import: glib.MainContext
import: glib.Source
import: gio.Cancellable
structWrap: GMainContext* MainContext
structWrap: GSource* Source
structWrap: GCancellable* Cancellable

#imports for AsyncResult Interface.
import: gio.AsyncResultIF
import: gio.AsyncResultT

nocode: g_task_get_source_object

code: start
	// add the AsyncResult capabilities
	mixin AsyncResultT!(GSimpleAsyncResult);
code: end
outFile: Task

file: gio-GIOScheduler.html
struct: GIOSchedulerJob
class: IOSchedulerJob
prefix: g_io_scheduler_job_
prefix: g_io_scheduler_
import: gio.Cancellable
structWrap: GCancellable* Cancellable
outFile: IOSchedulerJob

file: GSimpleAsyncResult.html
struct: GSimpleAsyncResult
class: SimpleAsyncResult
prefix: g_simple_async_result_
prefix: g_
implements: AsyncResultIF
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.ObjectG
import: gio.Cancellable
structWrap: GError* ErrorG
structWrap: GObject* ObjectG
structWrap: GCancellable* Cancellable

#imports for AsyncResult Interface.
import: gio.AsyncResultIF
import: gio.AsyncResultT

nocode: g_simple_async_result_new_take_error

code: start
	// add the AsyncResult capabilities
	mixin AsyncResultT!(GSimpleAsyncResult);
code: end
outFile: SimpleAsyncResult

###########################################################
### Data conversion #######################################
###########################################################

file: GConverter.html
struct: GConverter
class: ConverterT
template: TStruct
prefix: g_converter_
import: glib.ErrorG
import: glib.GException

array: g_converter_convert inbuf inbuf_size
array: g_converter_convert outbuf outbuf_size
out: g_converter_convert bytes_read
out: g_converter_convert bytes_written

interface: ConverterIF
outFile: ConverterT

file:
class: Converter
extend: ObjectG
implements: ConverterIF
import: gobject.ObjectG

# imports for Converter Interface
import: gio.ConverterT
import: gio.ConverterIF

code: start
	// Minimal implementation.
	mixin ConverterT!(GConverter);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gConverter;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GConverter* gConverter)
	{
		super(cast(GObject*)gConverter);
		this.gConverter = gConverter;
	}
code: end
outFile: Converter

file: GCharsetConverter.html
struct: GCharsetConverter
class: CharsetConverter
implements: ConverterIF
prefix: g_charset_converter_
import: glib.Str
import: glib.ErrorG
import: glib.GException

#imports for Converter Interface.
import: gio.ConverterT
import: gio.ConverterIF

code: start
	// add the Converter capabilities
	mixin ConverterT!(GCharsetConverter);
code: end
outFile: CharsetConverter

file: GZlibCompressor.html
struct: GZlibCompressor
class: ZlibCompressor
implements: ConverterIF
import: gio.FileInfo
structWrap: GFileInfo* FileInfo
prefix: g_zlib_compressor_

#imports for Converter Interface.
import: gio.ConverterT
import: gio.ConverterIF

code: start
	// add the Converter capabilities
	mixin ConverterT!(GZlibCompressor);
code: end
outFile: ZlibCompressor

file: GZlibDecompressor.html
struct: GZlibDecompressor
class: ZlibDecompressor
implements: ConverterIF
import: gio.FileInfo
structWrap: GFileInfo* FileInfo
prefix: g_zlib_decompressor_

#imports for Converter Interface.
import: gio.ConverterT
import: gio.ConverterIF

code: start
	// add the Converter capabilities
	mixin ConverterT!(GZlibDecompressor);
code: end
outFile: ZlibDecompressor

###########################################################
### Streaming I/O #########################################
###########################################################

file: GSeekable.html
struct: GSeekable
class: SeekableT
template: TStruct
prefix: g_seekable_
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
structWrap: GCancellable* Cancellable
interface: SeekableIF
outFile: SeekableT

file: GInputStream.html
struct: GInputStream
class: InputStream
prefix: g_input_stream_
import: glib.ErrorG
import: glib.GException
import: glib.Bytes
import: gio.AsyncResultIF
import: gio.Cancellable
structWrap: GBytes* Bytes
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
out: g_input_stream_read_all bytes_read
outFile: InputStream

file: GOutputStream.html
struct: GOutputStream
class: OutputStream
extend: GObject
prefix: g_output_stream_
import: glib.ErrorG
import: glib.GException
import: glib.Bytes
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
structWrap: GBytes* Bytes
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream
out: g_output_stream_write_all bytes_read
outFile: OutputStream

file: GIOStream.html
struct: GIOStream
class: IOStream
prefix: g_io_stream_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
import: gio.OutputStream
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream
structWrap: GIOStream* IOStream
structWrap: GOutputStream* OutputStream
outFile: IOStream

file: GFileInputStream.html
struct: GFileInputStream
class: FileInputStream
implements: SeekableIF
prefix: g_file_input_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.FileInfo
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFileInfo* FileInfo

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GFileInputStream);
code: end
outFile: FileInputStream

file: GFileOutputStream.html
struct: GFileOutputStream
class: FileOutputStream
implements: SeekableIF
prefix: g_file_output_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.FileInfo
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFileInfo* FileInfo

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GFileOutputStream);
code: end
outFile: FileOutputStream

file: GFileIOStream.html
struct: GFileIOStream
class: FileIOStream
implements: SeekableIF
prefix: g_file_io_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.FileInfo
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GFileInfo* FileInfo

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GFileIOStream);
code: end
outFile: FileIOStream

file: GFileDescriptorBased.html
struct: GFileDescriptorBased
class: FileDescriptorBasedT
template: TStruct
prefix: g_file_descriptor_based_
interface: FileDescriptorBasedIF
outFile: FileDescriptorBasedT

file: GFilterInputStream.html
struct: GFilterInputStream
class: FilterInputStream
prefix: g_filter_input_stream_
import: gio.InputStream
structWrap: GInputStream* InputStream
outFile: FilterInputStream

file: GFilterOutputStream.html
struct: GFilterOutputStream
class: FilterOutputStream
prefix: g_filter_output_stream_
import: gio.OutputStream
structWrap: GOutputStream* OutputStream
outFile: FilterOutputStream

file: GMemoryInputStream.html
struct: GMemoryInputStream
ctorStruct: GInputStream
class: MemoryInputStream
implements: SeekableIF
prefix: g_memory_input_stream_
import: glib.Bytes
structWrap: GBytes* Bytes

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GMemoryInputStream);
code: end
outFile: MemoryInputStream

file: GMemoryOutputStream.html
struct: GMemoryOutputStream
ctorStruct: GOutputStream
class: MemoryOutputStream
implements: SeekableIF
prefix: g_memory_output_stream_

#imports for Seekable Interface.
import: gio.SeekableT
import: gio.SeekableIF

code: start
	// add the Seekable capabilities
	mixin SeekableT!(GMemoryOutputStream);
code: end
outFile: MemoryOutputStream

file: GBufferedInputStream.html
struct: GBufferedInputStream
ctorStruct: GInputStream
class: BufferedInputStream
prefix: g_buffered_input_stream_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream
out: g_buffered_input_stream_peek_buffer count
outFile: BufferedInputStream

file: GBufferedOutputStream.html
struct: GBufferedOutputStream
ctorStruct: GOutputStream
class: BufferedOutputStream
prefix: g_buffered_output_stream_
import: gio.OutputStream
structWrap: GOutputStream* OutputStream
outFile: BufferedOutputStream

file: GDataInputStream.html
struct: GDataInputStream
class: DataInputStream
prefix: g_data_input_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream

out: g_data_input_stream_read_line_finish result
out: g_data_input_stream_read_upto_finish result
out: g_data_input_stream_read_until_finish result
array:  g_data_input_stream_read_line Return length
array: g_data_input_stream_read_line_finish Return length
array: g_data_input_stream_read_upto stop_chars stop_chars_len
array: g_data_input_stream_read_upto Return length
array: g_data_input_stream_read_upto_async stop_chars stop_chars_len
array: g_data_input_stream_read_upto_finish Return length
array: g_data_input_stream_read_until Return length
array: g_data_input_stream_read_until_finish Return length
out: g_data_input_stream_read_line_finish_utf8 length
out: g_data_input_stream_read_line_utf8 length

nocode: g_data_input_stream_read_byte
outFile: DataInputStream

file: GDataOutputStream.html
struct: GDataOutputStream
class: DataOutputStream
prefix: g_data_output_stream_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
import: gio.OutputStream
structWrap: GCancellable* Cancellable
structWrap: GOutputStream* OutputStream
outFile: DataOutputStream

file: GUnixInputStream.html
struct: GUnixInputStream
ctorStruct: GInputStream
class: UnixInputStream
implements: PollableInputStreamIF
prefix: g_unix_input_stream_

#imports for PollableInputStream Interface.
import: gio.PollableInputStreamT
import: gio.PollableInputStreamIF

code: start
	// add the PollableInputStream capabilities
	mixin PollableInputStreamT!(GUnixInputStream);
code: end
outFile: UnixInputStream

file: GUnixOutputStream.html
struct: GUnixOutputStream
ctorStruct: GOutputStream
class: UnixOutputStream
implements: PollableOutputStreamIF
prefix: g_unix_output_stream_

#imports for PollableOutputStream Interface.
import: gio.PollableOutputStreamT
import: gio.PollableOutputStreamIF

code: start
	// add the PollableOutputStream capabilities
	mixin PollableOutputStreamT!(GUnixOutputStream);
code: end
outFile: UnixOutputStream

file: gio-GConverterInputstream.html
struct: GConverterInputStream
ctorStruct: GInputStream
class: ConverterInputStream
prefix: g_converter_input_stream_
import: gio.Converter
import: gio.ConverterIF
structWrap: GConverter* ConverterIF
outFile: ConverterInputStream

file: gio-GConverterOutputstream.html
struct: GConverterOutputStream
ctorStruct: GOutputStream
class: ConverterOutputStream
prefix: g_converter_output_stream_
import: gio.Converter
import: gio.ConverterIF
structWrap: GConverter* ConverterIF
outFile: ConverterOutputStream

file: GPollableInputStream.html
struct: GPollableInputStream
class: PollableInputStreamT
template: TStruct
prefix: g_pollable_input_stream_
import: gobject.ObjectG
import: glib.ErrorG
import: glib.GException
import: glib.Source
import: gio.Cancellable
structWrap: GObject* ObjectG
structWrap: GCancellable* Cancellable
structWrap: GSource* Source
array: g_pollable_input_stream_read_nonblocking buffer size
interface: PollableInputStreamIF
outFile: PollableInputStreamT

file: GPollableOutputStream.html
struct: GPollableOutputStream
class: PollableOutputStreamT
template: TStruct
prefix: g_pollable_input_stream_
import: glib.ErrorG
import: glib.GException
import: glib.Source
import: gio.Cancellable
structWrap: GCancellable* Cancellable
structWrap: GSource* Source
array: g_pollable_output_stream_write_nonblocking buffer size
interface: PollableOutputStreamIF
outFile: PollableOutputStreamT

file: gio-gpollableutils.html
prefix: g_
import: gobject.ObjectG
import: glib.ErrorG
import: glib.GException
import: glib.Source
import: gio.Cancellable
import: gio.InputStream
import: gio.OutputStream
structWrap: GObject* ObjectG
structWrap: GSource* Source
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream
structWrap: GOutputStream* OutputStream

array: g_pollable_stream_read buffer count
array: g_pollable_stream_write buffer count
array: g_pollable_stream_write_all buffer count
out: g_pollable_stream_write_all bytes_written

outFile: PollableUtils

###########################################################
### File types and applications ###########################
###########################################################

file: gio-GContentType.html
class: ContentType
prefix: g_content_type_
import: glib.Str
import: glib.ListG
import: gio.File
import: gio.Icon
import: gio.IconIF
structWrap: GList* ListG
structWrap: GFile* File
structWrap: GIcon* IconIF
array: g_content_type_guess data data_size
out: g_content_type_guess result_uncertain
outFile: ContentType

file: GAppInfo.html
struct: GAppInfo
class: AppInfoT
template: TStruct
prefix: g_app_info_
noprefix: g_app_launch_context_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.AppInfoIF
import: gio.AppLaunchContext
import: gio.Icon
import: gio.IconIF
structWrap: GList* ListG
structWrap: GAppInfo* AppInfoIF
structWrap: GAppLaunchContext* AppLaunchContext
structWrap: GIcon* IconIF
interface: AppInfoIF
outFile: AppInfoT

file:
class: AppInfo
extend: ObjectG
implements: AppInfoIF
import: gobject.ObjectG

# imports for AppInfo Interface
import: gio.AppInfoT
import: gio.AppInfoIF

code: start
	// Minimal implementation.
	mixin AppInfoT!(GAppInfo);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gAppInfo;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GAppInfo* gAppInfo)
	{
		super(cast(GObject*)gAppInfo);
		this.gAppInfo = gAppInfo;
	}
code: end
outFile: AppInfo

struct: GAppLaunchContext
class: AppLaunchContext
extend: GObject
prefix: g_app_launch_context_
strictPrefix: Y
import: glib.Str
import: glib.ListG
import: gio.AppInfoIF
structWrap: GList* ListG
structWrap: GAppInfo* AppInfoIF
outFile: AppLaunchContext

file: gio-Desktop-file-based-GAppInfo.html
struct: GDesktopAppInfo
class: DesktopAppInfo
implements: AppInfoIF
prefix: g_desktop_app_info_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: glib.KeyFile
import: gio.AppInfo
import: gio.AppInfoIF
import: gio.AppLaunchContext
structWrap: GList* ListG
structWrap: GKeyFile* KeyFile
structWrap: GAppInfo* AppInfoIF
structWrap: GAppLaunchContext* AppLaunchContext

#imports for AppInfo Interface.
import: gio.AppInfoT
import: gio.AppInfoIF

nocode: g_desktop_app_info_new_from_filename

code: start
	// add the AppInfo capabilities
	mixin AppInfoT!(GDesktopAppInfo);

	public static DesktopAppInfo createFromFilename(string filename)
	{
		auto p = g_desktop_app_info_new_from_filename(Str.toStringz(filename));

		if(p is null)
		{
			throw new ConstructionException("null returned by g_desktop_app_info_new_from_filename");
		}
		
		return new DesktopAppInfo(p);
	}
code: end
outFile: DesktopAppInfo

###########################################################
### Volumes and Drives ####################################
###########################################################

file: GVolumeMonitor.html
struct: GVolumeMonitor
class: VolumeMonitor
prefix: g_volume_monitor_
import: glib.Str
import: glib.ListG
import: gio.Drive
import: gio.DriveIF
import: gio.Mount
import: gio.MountIF
import: gio.Volume
import: gio.VolumeIF
structWrap: GList* ListG
structWrap: GDrive* DriveIF
structWrap: GMount* MountIF
structWrap: GVolume* VolumeIF
structWrap: GVolumeMonitor*

nocode: g_volume_monitor_get

code: start
	/**
	 * Gets the volume monitor used by gio.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this()
	{
		// GVolumeMonitor* g_volume_monitor_get (void);
		auto p = g_volume_monitor_get();
		if(p is null)
		{
			throw new ConstructionException("g_volume_monitor_get()");
		}
		this(cast(GVolumeMonitor*) p);
	}
code: end
outFile: VolumeMonitor

file: GVolume.html
struct: GVolume
class: VolumeT
template: TStruct
prefix: g_volume_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.Signals
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Drive
import: gio.DriveIF
import: gio.File
import: gio.Icon
import: gio.IconIF
import: gio.Mount
import: gio.MountIF
import: gio.MountOperation
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GDrive* DriveIF
structWrap: GFile* File
structWrap: GIcon* IconIF
structWrap: GMount* MountIF
structWrap: GMountOperation* MountOperation
interface: VolumeIF
outFile: VolumeT

file:
class: Volume
extend: ObjectG
implements: VolumeIF
import: gobject.ObjectG

# imports for Volume Interface
import: gio.VolumeT
import: gio.VolumeIF

code: start
	// Minimal implementation.
	mixin VolumeT!(GVolume);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gVolume;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GVolume* gVolume)
	{
		super(cast(GObject*)gVolume);
		this.gVolume = gVolume;
	}
code: end
outFile: Volume

file: GMount.html
struct: GMount
class: MountT
template: TStruct
prefix: g_mount_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.Signals
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Drive
import: gio.DriveIF
import: gio.File
import: gio.Icon
import: gio.IconIF
import: gio.MountOperation
import: gio.Volume
import: gio.VolumeIF
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GDrive* DriveIF
structWrap: GFile* File
structWrap: GIcon* IconIF
structWrap: GMountOperation* MountOperation
structWrap: GVolume* VolumeIF
interface: MountIF
outFile: MountT

file:
class: Mount
extend: ObjectG
implements: MountIF
import: gobject.ObjectG

# imports for Mount Interface
import: gio.MountT
import: gio.MountIF

code: start
	// Minimal implementation.
	mixin MountT!(GMount);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gMount;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GMount* gMount)
	{
		super(cast(GObject*)gMount);
		this.gMount = gMount;
	}
code: end
outFile: Mount

file: GDrive.html
struct: GDrive
class: DriveT
template: TStruct
prefix: g_drive_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gobject.Signals
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Icon
import: gio.IconIF
import: gio.MountOperation
structWrap: GList* ListG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GIcon* IconIF
structWrap: GMountOperation* MountOperation
interface: DriveIF
outFile: DriveT

file:
class: Drive
extend: ObjectG
implements: DriveIF
import: gobject.ObjectG

# imports for Drive Interface
import: gio.DriveT
import: gio.DriveIF

code: start
	// Minimal implementation.
	mixin DriveT!(GDrive);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gDrive;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GDrive* gDrive)
	{
		super(cast(GObject*)gDrive);
		this.gDrive = gDrive;
	}
code: end
outFile: Drive

file: gio-Unix-Mounts.html
struct: GUnixMountEntry
class: UnixMountEntry
prefix: g_unix_mount_
prefix: g_unix_
noprefix: g_unix_mount_point_
noprefix: g_unix_mount_monitor_
import: glib.Str
import: glib.ListG
import: gio.Icon
import: gio.IconIF
structWrap: GList* ListG
structWrap: GIcon* IconIF
structWrap: GUnixMountEntry* UnixMountEntry

inout: g_unix_mounts_get time_read
inout: g_unix_mount_at time_read
nosignal: mountpoints-changed
nosignal: mounts-changed

outFile: UnixMountEntry

struct: GUnixMountPoint
class: UnixMountPoint
prefix: g_unix_mount_point_
strictPrefix: Y
import: glib.Str
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF
structWrap: GUnixMountPoint* UnixMountPoint

inout: g_unix_mount_points_get time_read
nosignal: mountpoints-changed
nosignal: mounts-changed

outFile: UnixMountPoint

struct: GUnixMountMonitor
class: UnixMountMonitor
prefix: g_unix_mount_monitor_
strictPrefix: Y
outFile: UnixMountMonitor

###########################################################
### Icons #################################################
###########################################################

file: GIcon.html
struct: GIcon
class: IconT
template: TStruct
prefix: g_icon_
import: glib.Str
import: glib.ErrorG
import: glib.GException
override: toString
#Skip this one for now
nocode: g_icon_new_for_string
interface: IconIF
outFile: IconT

file:
class: Icon
extend: ObjectG
implements: IconIF
import: gobject.ObjectG

#imports for Icon Interface.
import: gio.IconT
import: gio.IconIF

code: start
	// Minimal implementation.
	mixin IconT!(GIcon);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gIcon;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GIcon* gIcon)
	{
		super(cast(GObject*)gIcon);
		this.gIcon = gIcon;
	}
code: end
outFile: Icon

file: GFileIcon.html
struct: GFileIcon
ctorStruct: GIcon
class: FileIcon
implements: IconIF
implements: LoadableIconIF
prefix: g_file_icon_

#imports for Icon Interface.
import: gio.IconT
import: gio.IconIF

#imports for LoadableIcon Interface.
import: gio.LoadableIconT
import: gio.LoadableIconIF

code: start
	// add the Icon capabilities
	mixin IconT!(GFileIcon);

	// add the LoadableIcon capabilities
	mixin LoadableIconT!(GFileIcon);
code: end
outFile: FileIcon

file: GLoadableIcon.html
struct: GLoadableIcon
class: LoadableIconT
template: TStruct
prefix: g_loadable_icon_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.InputStream
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GInputStream* InputStream

out: g_loadable_icon_load type
out: g_loadable_icon_load_finish type

interface: LoadableIconIF
outFile: LoadableIconT

file: GThemedIcon.html
struct: GThemedIcon
ctorStruct: GIcon
class: ThemedIcon
implements: IconIF
prefix: g_themed_icon_
import: glib.Str

#imports for Icon Interface.
import: gio.IconT
import: gio.IconIF

array: g_themed_icon_new_from_names iconnames
nocode: g_themed_icon_new

code: start
	// add the Icon capabilities
	mixin IconT!(GThemedIcon);
code: end
outFile: ThemedIcon

file: GEmblemedIcon.html
struct: GEmblemedIcon
ctorStruct: GIcon
class: EmblemedIcon
implements: IconIF
prefix: g_emblemed_icon_
import: glib.ListG
import: gio.Emblem
import: gio.Icon
import: gio.IconIF
structWrap: GList* ListG
structWrap: GEmblem* Emblem
structWrap: GIcon* IconIF

#imports for Icon Interface.
import: gio.IconT
#import: gio.IconIF

array: g_themed_icon_new_from_names iconnames

code: start
	// add the Icon capabilities
	mixin IconT!(GEmblemedIcon);
code: end
outFile: EmblemedIcon

file: GEmblem.html
struct: GEmblem
class: Emblem
implements: IconIF
prefix: g_emblem_
import: gio.Icon
import: gio.IconIF
structWrap: GIcon* IconIF

#imports for Icon Interface.
import: gio.IconT
#import: gio.IconIF

array: g_themed_icon_new_from_names iconnames

code: start
	// add the Icon capabilities
	mixin IconT!(GEmblem);
code: end
outFile: Emblem

###########################################################
### Failable Initialization ###############################
###########################################################

file: GInitable.html
struct: GInitable
class: InitableT
template: TStruct
prefix: g_initable_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.ObjectG
import: gio.Cancellable
structWrap: GObject* ObjectG
structWrap: GCancellable* Cancellable
array: g_initable_newv parameters n_parameters
interface: InitableIF
outFile: InitableT

file: GAsyncInitable.html
struct: GAsyncInitable
class: AsyncInitableT
template: TStruct
prefix: g_initable_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gobject.ObjectG
import: gio.AsyncResultIF
import: gio.Cancellable
structWrap: GObject* ObjectG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
array: g_async_initable_newv_async parameters n_parameters
interface: AsyncInitableIF
outFile: AsyncInitableT

###########################################################
### Lowlevel network support ##############################
###########################################################

file: GSocket.html
struct: GSocket
class: Socket
implements: InitableIF
prefix: g_socket_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Source
import: gio.Cancellable
import: gio.Credentials
import: gio.InetAddress
import: gio.SocketAddress
import: gio.SocketControlMessage
structWrap: GSource* Source
structWrap: GCancellable* Cancellable
structWrap: GCredentials* Credentials
structWrap: GInetAddress* InetAddress
structWrap: GSocketAddress* SocketAddress
structWrap: GSocketControlMessage* SocketControlMessage

#imports for Initable Interface.
import: gio.InitableT
import: gio.InitableIF

alias: GLIB_SYSDEF_MSG_OOB 1
alias: GLIB_SYSDEF_MSG_PEEK 2
alias: GLIB_SYSDEF_MSG_DONTROUTE 4

inout: g_socket_receive_from address
array: g_socket_receive_from buffer size
inout: g_socket_receive_message address
array: g_socket_receive_message vectors num_vectors
inout: g_socket_receive_message messages
array: g_socket_receive_message messages num_messages
inout: g_socket_receive_message flags
array: g_socket_send_message vectors num_vectors
inout: g_socket_send_message messages
array: g_socket_send_message messages num_messages
out: g_socket_get_option value

code: start
	// add the Initable capabilities
	mixin InitableT!(GSocket);
code: end
outFile: Socket

file: GInetAddress.html
struct: GInetAddress
class: InetAddress
prefix: g_inet_address_
import: glib.Str
override: toString
structWrap: GInetAddress* InetAddress

array: g_inet_address_new_from_bytes bytes
array: g_inet_address_to_bytes Return getNativeSize()

nocode: g_inet_address_new_any
nocode: g_inet_address_new_loopback

code: start
	/**
	 * Creates a GInetAddress for the "any" address (unassigned/"don't
	 * care") for family.
	 * Since 2.22
	 * Params:
	 * family = the address family
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (GSocketFamily family, bool loopback = false)
	{
		// GInetAddress * g_inet_address_new_any (GSocketFamily family);
		GInetAddress* p;

		if ( loopback )
		{
			p = g_inet_address_new_loopback(family);
		}
		else
		{
			p = g_inet_address_new_any(family);
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by g_inet_address_new_any(family)");
		}
		this(cast(GInetAddress*) p);
	}
code: end
outFile: InetAddress

file: gio-GInetAddressMask.html
struct: GInetAddressMask
class: InetAddressMask
extend: GObject
prefix: g_inet_address_mask_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.InetAddress
structWrap: GInetAddress* InetAddress
structWrap: GInetAddressMask* InetAddressMask
override: toString
outFile: InetAddressMask

file: GSocketAddress.html
struct: GSocketAddress
class: SocketAddress
implements: SocketConnectableIF
prefix: g_socket_address_
import: glib.ErrorG
import: glib.GException

#imports for SocketConnectable Interface.
import: gio.SocketConnectableT
import: gio.SocketConnectableIF

alias: GLIB_SYSDEF_AF_UNIX 1
alias: GLIB_SYSDEF_AF_INET 2
alias: GLIB_SYSDEF_AF_INET6 23

code: start
	// add the SocketConnectable capabilities
	mixin SocketConnectableT!(GSocketAddress);
code: end
outFile: SocketAddress

file: GInetSocketAddress.html
struct: GInetSocketAddress
ctorStruct: GSocketAddress
class: InetSocketAddress
prefix: g_inet_socket_address_
import: gio.InetAddress
structWrap: GInetAddress* InetAddress
outFile: InetSocketAddress

file: GUnixSocketAddress.html
struct: GUnixSocketAddress
ctorStruct: GSocketAddress
class: UnixSocketAddress
prefix: g_unix_socket_address_
import: glib.Str
array: g_unix_socket_address_new_with_type path path_len
outFile: UnixSocketAddress

file: GSocketControlMessage.html
struct: GSocketControlMessage
class: SocketControlMessage
prefix: g_socket_control_message_
structWrap: GSocketControlMessage* SocketControlMessage
outFile: SocketControlMessage

file: GUnixFDList.html
struct: GUnixFDList
class: UnixFDList
prefix: g_unix_fd_list_
import: glib.ErrorG
import: glib.GException

array: g_unix_fd_list_new_from_array fds n_fds
array: g_unix_fd_list_peek_fds Return length
array: g_unix_fd_list_steal_fds Return length
outFile: UnixFDList

file: GUnixFDMessage.html
struct: GUnixFDMessage
ctorStruct: GSocketControlMessage
class: UnixFDMessage
prefix: g_unix_fd_message_
import: glib.ErrorG
import: glib.GException
import: gio.UnixFDList
structWrap: GUnixFDList* UnixFDList
array: g_unix_fd_message_steal_fds Return length
outFile: UnixFDMessage

file: GCredentials.html
struct: GCredentials
class: Credentials
prefix: g_credentials_
override: toString
import: glib.Str
import: glib.ErrorG
import: glib.GException
structWrap: GCredentials* Credentials
outFile: Credentials

file: GUnixCredentialsMessage.html
struct: GUnixCredentialsMessage
ctorStruct: GSocketControlMessage
class: UnixCredentialsMessage
prefix: g_unix_credentials_message_
import: gio.Credentials
structWrap: GCredentials* Credentials
outFile: UnixCredentialsMessage

file: GProxy.html
struct: GProxy
class: ProxyT
template: TStruct
prefix: g_initable_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.IOStream
import: gio.ProxyAddress
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GIOStream* IOStream
structWrap: GProxy* ProxyIF
structWrap: GProxyAddress* ProxyAddress
interface: ProxyIF
outFile: ProxyT

file:
class: Proxy
extend: ObjectG
implements: ProxyIF
import: gobject.ObjectG

#imports for Proxy Interface.
import: gio.ProxyT
import: gio.ProxyIF

code: start
	// Minimal implementation.
	mixin ProxyT!(GProxy);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gProxy;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GProxy* gProxy)
	{
		super(cast(GObject*)gProxy);
		this.gProxy = gProxy;
	}
code: end
outFile: Proxy

file: GProxyAddress.html
struct: GProxyAddress
ctorStruct: GSocketAddress
class: ProxyAddress
prefix: g_proxy_address_
import: glib.Str
outFile: ProxyAddress

###########################################################
### Highlevel network functionallity ######################
###########################################################

file: GSocketClient.html
struct: GSocketClient
class: SocketClient
prefix: g_socket_client_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.IOStream
import: gio.ProxyResolver
import: gio.ProxyResolverIF
import: gio.SocketAddress
import: gio.SocketConnection
import: gio.SocketConnectable
import: gio.SocketConnectableIF
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GIOStream* IOStream
structWrap: GProxyResolver* ProxyResolverIF
structWrap: GSocketAddress* SocketAddress
structWrap: GSocketConnection* SocketConnection
structWrap: GSocketConnectable* SocketConnectableIF
outFile: SocketClient

file: GSocketConnection.html
struct: GSocketConnection
class: SocketConnection
prefix: g_socket_connection_
noprefix: g_tcp_connection_
noprefix: g_unix_connection_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Socket
import: gio.SocketAddress
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GSocket* Socket
structWrap: GSocketAddress* SocketAddress
structWrap: GSocketConnection* SocketConnection
outFile: SocketConnection

file: GUnixConnection.html
struct: GUnixConnection
class: UnixConnection
prefix: g_unix_connection_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Credentials
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GCredentials* Credentials
outFile: UnixConnection

file: GTcpConnection.html
struct: GTcpConnection
class: TcpConnection
prefix: g_tcp_connection_
outFile: TcpConnection

file: GSocketListener.html
struct: GSocketListener
class: SocketListener
prefix: g_socket_listener_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Socket
import: gio.SocketAddress
import: gio.SocketConnection
structWrap: GObject* ObjectG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GSocketAddress* SocketAddress
structWrap: GSocketConnection* SocketConnection
structWrap: GSocket* Socket

out: g_socket_listener_add_address effective_address
out: g_socket_listener_accept source_object
inout: g_socket_listener_accept_finish source_object
out: g_socket_listener_accept_socket source_object
inout: g_socket_listener_accept_socket_finish source_object
outFile: SocketListener

file: GSocketService.html
struct: GSocketService
class: SocketService
prefix: g_socket_service_
outFile: SocketService

file: GThreadedSocketService.html
struct: GThreadedSocketService
ctorStruct: GSocketService
class: ThreadedSocketService
prefix: g_threaded_socket_service_
outFile: ThreadedSocketService

file: GNetworkMonitor.html
struct: GNetworkMonitor
class: NetworkMonitorT
template: TStruct
prefix: g_network_monitor_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.NetworkMonitorIF
import: gio.SocketConnectableIF
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GNetworkMonitor* NetworkMonitorIF
structWrap: GSocketConnectable* SocketConnectableIF
interface: NetworkMonitorIF
outFile: NetworkMonitorT

file:
class: NetworkMonitor
extend: GObject
implements: InitableIF
implements: NetworkMonitorIF

#imports for Initable Interface.
import: gio.InitableIF
import: gio.InitableT

# imports for NetworkMonitor Interface
import: gio.NetworkMonitorT
import: gio.NetworkMonitorIF

code: start
	// Minimal implementation.
	mixin NetworkMonitorT!(GNetworkMonitor);

	// add the Initable capabilities
	mixin InitableT!(GNetworkMonitor);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gNetworkMonitor;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GNetworkMonitor* gNetworkMonitor)
	{
		super(cast(GObject*)gNetworkMonitor);
		this.gNetworkMonitor = gNetworkMonitor;
	}
code: end
outFile: NetworkMonitor

###########################################################
### TLS (SSL) Support #####################################
###########################################################

file: GTlsCertificate.html
struct: GTlsCertificate
class: TlsCertificate
prefix: g_tls_certificate_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.SocketConnectableIF
structWrap: GList* ListG
structWrap: GSocketConnectable* SocketConnectableIF
structWrap: GTlsCertificate* TlsCertificate
array: g_tls_certificate_new_from_pem data length

#conflicts with: g_tls_certificate_new_from_pem
nocode: g_tls_certificate_new_from_file
openFile: TlsCertificate

file: gio-TLS-Overview.html
closeFile: TlsCertificate

file: GTlsConnection.html
struct: GTlsConnection
ctorStruct: GIOStream
class: TlsConnection
prefix: g_tls_connection_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.TlsCertificate
import: gio.TlsDatabase
import: gio.TlsInteraction
structWrap: GCancellable* Cancellable
structWrap: GTlsCertificate* TlsCertificate
structWrap: GTlsDatabase* TlsDatabase
structWrap: GTlsInteraction* TlsInteraction
outFile: TlsConnection

file: GTlsClientConnection.html
struct: GTlsClientConnection
ctorStruct: GIOStream
class: TlsClientConnection
extend: GTlsConnection
prefix: g_tls_client_connection_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.IOStream
import: gio.SocketConnectable
import: gio.SocketConnectableIF
structWrap: GList* ListG
structWrap: GIOStream* IOStream
structWrap: GSocketConnectable* SocketConnectableIF
outFile: TlsClientConnection

file: GTlsServerConnection.html
struct: GTlsServerConnection
ctorStruct: GIOStream
class: TlsServerConnection
extend: GTlsConnection
prefix: g_tls_server_connection_
import: glib.ErrorG
import: glib.GException
import: gio.IOStream
import: gio.TlsCertificate
structWrap: GIOStream* IOStream
structWrap: GTlsCertificate* TlsCertificate
outFile: TlsServerConnection

file: GTlsBackend.html
struct: GTlsBackend
class: TlsBackend
prefix: g_tls_backend_
import: gio.TlsDatabase
structWrap: GTlsBackend* TlsBackend
structWrap: GTlsDatabase* TlsDatabase
outFile: TlsBackend

file: GTlsDatabase.html
struct: GTlsDatabase
class: TlsDatabase
prefix: g_tls_database_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ByteArray
import: glib.ListG
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.SocketConnectableIF
import: gio.TlsCertificate
import: gio.TlsInteraction
structWrap: GByteArray* ByteArray
structWrap: GList* ListG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GSocketConnectable* SocketConnectableIF
structWrap: GTlsCertificate* TlsCertificate
structWrap: GTlsInteraction* TlsInteraction
outFile: TlsDatabase

# Interface ?
file: GTlsFileDatabase.html
struct: GTlsFileDatabase
ctorStruct: GTlsDatabase
class: TlsFileDatabase
extend: GTlsDatabase
prefix: g_tls_file_database_
import: glib.Str
import: glib.ErrorG
import: glib.GException
outFile: TlsFileDatabase

file: GTlsInteraction.html
struct: GTlsInteraction
class: TlsInteraction
prefix: g_tls_interaction_
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.TlsPassword
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GTlsPassword* TlsPassword
outFile: TlsInteraction

file: GTlsPassword.html
struct: GTlsPassword
class: TlsPassword
prefix: g_tls_password_
import: glib.Str
array: g_tls_password_get_value Return length
array: g_tls_password_set_value value length
array: g_tls_password_set_value_full value length
outFile: TlsPassword

###########################################################
### DNS resolution ########################################
###########################################################

file: GResolver.html
struct: GResolver
class: Resolver
prefix: g_resolver_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gio.AsyncResultIF
import: gio.Cancellable
structWrap: GList* ListG
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GResolver* Resolver
outFile: Resolver

file: GProxyResolver.html
struct: GProxyResolver
class: ProxyResolverT
template: TStruct
prefix: g_proxy_resolver_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.ProxyResolver
import: gio.ProxyResolverIF
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GProxyResolver* ProxyResolverIF
interface: ProxyResolverIF
outFile: ProxyResolverT

file:
class: ProxyResolver
extend: ObjectG
implements: ProxyResolverIF
import: glib.Str

#imports for ProxyResolver Interface.
import: gio.ProxyResolverT
import: gio.ProxyResolverIF

array: g_simple_proxy_resolver_new ignore_hosts
array: g_simple_proxy_resolver_set_ignore_hosts ignore_hosts

code: sta
	// Minimal implementation.
	mixin ProxyResolverT!(GProxyResolver);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gProxyResolver;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GProxyResolver* gProxyResolver)
	{
		super(cast(GObject*)gProxyResolver);
		this.gProxyResolver = gProxyResolver;
	}
code: end
outFile: ProxyResolver

file: GSimpleProxyResolver.html
struct: GSimpleProxyResolver
class: SimpleProxyResolver
implements: ProxyResolverIF
prefix: g_simple_proxy_resolver_

#imports for ProxyResolver Interface.
import: gio.ProxyResolverT
import: gio.ProxyResolverIF

code: start
	// Minimal implementation.
	mixin ProxyResolverT!(GProxyResolver);
code: end
outFile: SimpleProxyResolver

file: GSocketConnectable.html
struct: GSocketConnectable
class: SocketConnectableT
template: TStruct
prefix: g_socket_connectable_
noprefix: g_socket_address_enumerator_
import: gio.SocketAddressEnumerator
structWrap: GSocketAddressEnumerator* SocketAddressEnumerator
interface: SocketConnectableIF
outFile: SocketConnectableT

file:
class: SocketConnectable
extend: ObjectG
implements: SocketConnectableIF
import: gobject.ObjectG

#imports for SocketConnectable Interface.
import: gio.SocketConnectableT
import: gio.SocketConnectableIF

code: start
	// Minimal implementation.
	mixin SocketConnectableT!(GSocketConnectable);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gSocketConnectable;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GSocketConnectable* gSocketConnectable)
	{
		super(cast(GObject*)gSocketConnectable);
		this.gSocketConnectable = gSocketConnectable;
	}
code: end
outFile: SocketConnectable

struct: GSocketAddressEnumerator
class: SocketAddressEnumerator
prefix: g_socket_address_enumerator_
strictPrefix: Y
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.SocketAddress
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GSocketAddress* SocketAddress
outFile: SocketAddressEnumerator

file: GNetworkAddress.html
struct: GNetworkAddress
ctorStruct: GSocketConnectable
class: NetworkAddress
implements: SocketConnectableIF
prefix: g_network_address_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.SocketConnectable
import: gio.SocketConnectableIF
structWrap: GSocketConnectable* SocketConnectableIF

#imports for SocketConnectable Interface.
import: gio.SocketConnectableT
#import: gio.SocketConnectableIF

nocode: g_network_address_parse

code: start
	// add the SocketConnectable capabilities
	mixin SocketConnectableT!(GNetworkAddress);

	/**
	 * Creates a new GSocketConnectable for connecting to the given
	 * hostname and port. May fail and return NULL in case
	 * parsing host_and_port fails.
	 * host_and_port may be in any of a number of recognised formats: an IPv6
	 * address, an IPv4 address, or a domain name (in which case a DNS
	 * lookup is performed). Quoting with [] is supported for all address
	 * types. A port override may be specified in the usual way with a
	 * colon. Ports may be given as decimal numbers or symbolic names (in
	 * which case an /etc/services lookup is performed).
	 * If no port is specified in host_and_port then default_port will be
	 * used as the port number to connect to.
	 * In general, host_and_port is expected to be provided by the user
	 * (allowing them to give the hostname, and a port overide if necessary)
	 * and default_port is expected to be provided by the application.
	 * Since 2.22
	 * Params:
	 * hostAndPort =  the hostname and optionally a port
	 * defaultPort =  the default port if not in host_and_port
	 * Returns: the new GNetworkAddress, or NULL on error
	 * Throws: GException on failure.
	 */
	public static SocketConnectableIF parse(string hostAndPort, ushort defaultPort)
	{
		// GSocketConnectable * g_network_address_parse (const gchar *host_and_port,  guint16 default_port,  GError **error);
		GError* err = null;
		
		auto p = g_network_address_parse(Str.toStringz(hostAndPort), defaultPort, &err);
		
		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}
		
		if(p is null)
		{
			return null;
		}
		return new NetworkAddress(cast(GNetworkAddress*) p);
	}
code: end
outFile: NetworkAddress

file: GNetworkService.html
struct: GNetworkService
ctorStruct: GSocketConnectable
class: NetworkService
implements: SocketConnectableIF
prefix: g_network_service_
import: glib.Str

#imports for SocketConnectable Interface.
import: gio.SocketConnectableT
import: gio.SocketConnectableIF

code: start
	// add the SocketConnectable capabilities
	mixin SocketConnectableT!(GNetworkService);
code: end
outFile: NetworkService

file: GSrvTarget.html
struct: GSrvTarget
class: SrvTarget
prefix: g_srv_target_
import: glib.Str
import: glib.ListG
structWrap: GList* ListG
structWrap: GSrvTarget* SrvTarget
outFile: SrvTarget

###########################################################
### Lowlevel D-Bus Support ################################
###########################################################

file: gio-D-Bus-Utilities.html
class: DBusUtilities
prefix: g_dbus_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Variant
import: glib.VariantType
import: gobject.Value
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.IOStream
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType
structWrap: GValue* Value
openFile: DBusUtilities

file: gio-D-Bus-Addresses.html
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GIOStream* IOStream
out: g_dbus_address_get_stream_finish out_guid
out: g_dbus_address_get_stream_sync out_guid
closeFile: DBusUtilities

file: gio-D-Bus-Introspection-Data.html
struct: GDBusAnnotationInfo
class: DBusAnnotationInfo
prefix: g_dbus_annotation_info_
noprefix: g_dbus_interface_info_
noprefix: g_dbus_node_info_
noprefix: g_dbus_method_info_
noprefix: g_dbus_signal_info_
noprefix: g_dbus_property_info_
noprefix: g_dbus_arg_info_
import: glib.Str
structWrap: GDBusAnnotationInfo* DBusAnnotationInfo

nocode: g_dbus_annotation_info_lookup
code: start
	/**
	 * Looks up the value of an annotation.
	 * This cost of this function is O(n) in number of annotations.
	 * Since 2.26
	 * Params:
	 * annotations = A array of annotations or NULL.
	 * name = The name of the annotation to look up.
	 * Returns: The value or null if not found.
	 */
	public static string lookup(DBusAnnotationInfo[] annotations, string name)
	{
		// const gchar * g_dbus_annotation_info_lookup (GDBusAnnotationInfo **annotations,  const gchar *name);
		
		GDBusAnnotationInfo*[] annotationsArray = new GDBusAnnotationInfo*[annotations.length+1];
		for ( int i = 0; i < annotations.length ; i++ )
		{
			annotationsArray[i] = annotations[i].getDBusAnnotationInfoStruct();
		}
		annotationsArray[$-1] = null;
		
		return Str.toString(g_dbus_annotation_info_lookup(annotationsArray.ptr, Str.toStringz(name)));
	}
code: end
outFile: DBusAnnotationInfo

struct: GDBusArgInfo
class: DBusArgInfo
strictPrefix: Y
prefix: g_dbus_arg_info_
structWrap: GDBusArgInfo* DBusArgInfo
outFile: DBusArgInfo

struct: GDBusMethodInfo
class: DBusMethodInfo
strictPrefix: Y
prefix: g_dbus_method_info_
structWrap: GDBusMethodInfo* DBusMethodInfo
outFile: DBusMethodInfo

struct: GDBusSignalInfo
class: DBusSignalInfo
strictPrefix: Y
prefix: g_dbus_signal_info_
structWrap: GDBusSignalInfo* DBusSignalInfo
outFile: DBusSignalInfo

struct: GDBusPropertyInfo
class: DBusPropertyInfo
strictPrefix: Y
prefix: g_dbus_property_info_
structWrap: GDBusPropertyInfo* DBusPropertyInfo
outFile: DBusPropertyInfo

struct: GDBusInterfaceInfo
class: DBusInterfaceInfo
strictPrefix: Y
prefix: g_dbus_interface_info_
import: glib.Str
import: glib.StringG
import: gio.DBusMethodInfo
import: gio.DBusPropertyInfo
import: gio.DBusSignalInfo
structWrap: GString* StringG
structWrap: GDBusInterfaceInfo* DBusInterfaceInfo
structWrap: GDBusMethodInfo* DBusMethodInfo
structWrap: GDBusPropertyInfo* DBusPropertyInfo
structWrap: GDBusSignalInfo* DBusSignalInfo
outFile: DBusInterfaceInfo

struct: GDBusNodeInfo
class: DBusNodeInfo
strictPrefix: Y
prefix: g_dbus_node_info_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.StringG
import: gio.DBusInterfaceInfo
structWrap: GString* StringG
structWrap: GDBusInterfaceInfo* DBusInterfaceInfo
structWrap: GDBusNodeInfo* DBusNodeInfo
outFile: DBusNodeInfo

file: gio-GDBusError.html
struct: GError
class: DBusError
prefix: g_dbus_error_
import: glib.Str
import: glib.ErrorG
structWrap: GError* ErrorG
array: g_dbus_error_register_error_domain entries num_entries
out: g_dbus_error_register_error_domain quark_volatile
out: g_dbus_error_set_dbus_error error
out: g_dbus_error_set_dbus_error_valist error
outFile: DBusError

file: GDBusMessage.html
struct: GDBusMessage
class: DBusMessage
prefix: g_dbus_message_
alias: body bod
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Variant
import: gio.UnixFDList
structWrap: GError* ErrorG
structWrap: GVariant* Variant
structWrap: GDBusMessage* DBusMessage
structWrap: GUnixFDList* UnixFDList
array: g_dbus_message_to_blob Return out_size
array: g_dbus_message_bytes_needed blob blob_len
array: g_dbus_message_new_from_blob blob blob_len
out: g_dbus_message_to_gerror error
outFile: DBusMessage

file: GDBusConnection.html
struct: GDBusConnection
class: DBusConnection
extend: GObject
implements: InitableIF
implements: AsyncInitableIF
prefix: g_dbus_connection_
prefix: g_dbus_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Variant
import: glib.VariantType
import: gio.ActionGroupIF
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.Credentials
import: gio.DBusAuthObserver
import: gio.DBusMessage
import: gio.DBusMethodInvocation
import: gio.IOStream
import: gio.MenuModel
import: gio.UnixFDList
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GCredentials* Credentials
structWrap: GDBusAuthObserver* DBusAuthObserver
structWrap: GDBusConnection* DBusConnection
structWrap: GDBusMessage* DBusMessage
structWrap: GDBusMethodInvocation* DBusMethodInvocation
structWrap: GIOStream* IOStream
structWrap: GUnixFDList* UnixFDList

#imports for Initable Interface.
import: gio.InitableT
import: gio.InitableIF

#imports for AsyncInitable Interface.
import: gio.AsyncInitableT
import: gio.AsyncInitableIF

out: g_dbus_connection_send_message out_serial
out: g_dbus_connection_send_message_with_reply out_serial
out: g_dbus_connection_send_message_with_reply_sync out_serial
out: g_dbus_connection_call_with_unix_fd_list_finish out_fd_list
out: g_dbus_connection_call_with_unix_fd_list_sync out_fd_list

nocode: g_dbus_connection_new_finish
nocode: g_dbus_connection_new_for_address_finish

code: start
	// add the Initable capabilities
	mixin InitableT!(DBusConnection);

	// add the AsyncInitable capabilities
	mixin AsyncInitableT!(DBusConnection);

	/**
	 * Finishes an operation started with g_dbus_connection_new().
	 * Since 2.26
	 * Params:
	 *      res    = A GAsyncResult obtained from the GAsyncReadyCallback
	 *               passed to g_dbus_connection_new().
	 *     address = If true finish an address.
	 * Throws: GException on failure.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (AsyncResultIF res, bool address = false)
	{
		// GDBusConnection * g_dbus_connection_new_finish (GAsyncResult *res,  GError **error);
		GError* err = null;
		GDBusConnection* p;
		
		if ( address )
		{
			p = g_dbus_connection_new_for_address_finish((res is null) ? null : res.getAsyncResultTStruct(), &err);
		}
		else
		{
			p = g_dbus_connection_new_finish((res is null) ? null : res.getAsyncResultTStruct(), &err);
		}

		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}
		
		if(p is null)
		{
			throw new ConstructionException("null returned by g_dbus_connection_new_finish((res is null) ? null : res.getAsyncResultTStruct(), &err)");
		}
		this(cast(GDBusConnection*) p);
	}	
code: end
openFile: DBusConnection

file: gio-GActionGroup-exporter.html
structWrap: GActionGroup* ActionGroupIF
mergeFile: DBusConnection

file: gio-GMenuModel-exporter.html
structWrap: GMenuModel* MenuModel
closeFile: DBusConnection

file: GDBusMethodInvocation.html
struct: GDBusMethodInvocation
class: DBusMethodInvocation
prefix: g_dbus_method_invocation_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Variant
import: gio.DBusConnection
import: gio.DBusMessage
import: gio.UnixFDList
structWrap: GError* ErrorG
structWrap: GVariant* Variant
structWrap: GDBusConnection* DBusConnection
structWrap: GDBusMessage* DBusMessage
structWrap: GUnixFDList* UnixFDList
outFile: DBusMethodInvocation

file: GDBusServer.html
struct: GDBusServer
class: DBusServer
implements: InitableIF
prefix: g_dbus_server_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
import: gio.DBusAuthObserver
structWrap: GCancellable* Cancellable
structWrap: GDBusAuthObserver* DBusAuthObserver

#imports for Initable Interface.
import: gio.InitableT
import: gio.InitableIF

code: start
	// add the Initable capabilities
	mixin InitableT!(GDBusServer);
code: end
outFile: DBusServer

file: GDBusAuthObserver.html
struct: GDBusAuthObserver
class: DBusAuthObserver
prefix: g_dbus_auth_observer_
import: glib.Str
import: gio.Credentials
import: gio.IOStream
structWrap: GCredentials* Credentials
structWrap: GIOStream* IOStream
outFile: DBusAuthObserver

###########################################################
### HighLevel D-Bus Support ###############################
###########################################################

file: gio-Owning-Bus-Names.html
class: DBusNames
prefix: g_bus_
import: glib.Str
import: gobject.Closure
import: gio.DBusConnection
structWrap: GClosure* Closure
structWrap: GDBusConnection* DBusConnection
openFile: DBusNames

file: gio-Watching-Bus-Names.html
structWrap: GClosure* Closure
structWrap: GDBusConnection* DBusConnection
closeFile: DBusNames

file: GDBusInterface.html
struct: GDBusInterface
class: DBusInterfaceT
template: TStruct
prefix: g_dbus_interface_
import: gio.DBusInterfaceInfo
import: gio.DBusObject
import: gio.DBusObjectIF
structWrap: GDBusInterfaceInfo* DBusInterfaceInfo
structWrap: GDBusObject* DBusObjectIF
interface: DBusInterfaceIF
outFile: DBusInterfaceT

file:
class: DBusInterface
extend: ObjectG
implements: DBusInterfaceIF
import: gobject.ObjectG

# imports for DBusInterface Interface
import: gio.DBusInterfaceT
import: gio.DBusInterfaceIF

code: start
	// Minimal implementation.
	mixin DBusInterfaceT!(GDBusInterface);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gDBusInterface;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GDBusInterface* gDBusInterface)
	{
		super(cast(GObject*)gDBusInterface);
		this.gDBusInterface = gDBusInterface;
	}
code: end
outFile: DBusInterface

file: GDBusInterfaceSkeleton.html
struct: GDBusInterfaceSkeleton
class: DBusInterfaceSkeleton
implements: DBusInterfaceIF
prefix: g_dbus_interface_skeleton_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: glib.Variant
import: gio.DBusConnection
import: gio.DBusInterfaceInfo
structWrap: GList* ListG
structWrap: GVariant* Variant
structWrap: GDBusConnection* DBusConnection
structWrap: GDBusInterfaceInfo* DBusInterfaceInfo

nocode: g_dbus_interface_skeleton_get_info

# imports for DBusInterface Interface
import: gio.DBusInterfaceT
import: gio.DBusInterfaceIF

code: start
	// add the DBusInterface capabilities
	mixin DBusInterfaceT!(GDBusInterfaceSkeleton);
code: end
outFile: DBusInterfaceSkeleton

file: GDBusProxy.html
struct: GDBusProxy
class: DBusProxy
extend: GObject
implements: AsyncInitableIF
implements: DBusInterfaceIF
implements: InitableIF
prefix: g_dbus_proxy_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Variant
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.DBusConnection
import: gio.UnixFDList
structWrap: GVariant* Variant
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GDBusConnection* DBusConnection
structWrap: GUnixFDList* UnixFDList

out: g_dbus_proxy_call_with_unix_fd_list_finish out_fd_list
out: g_dbus_proxy_call_with_unix_fd_list_sync out_fd_list

# imports for AsyncInitable Interface
import: gio.AsyncInitableT
import: gio.AsyncInitableIF

# imports for DBusInterface Interface
import: gio.DBusInterfaceT
import: gio.DBusInterfaceIF

# imports for Initable Interface
import: gio.InitableT
import: gio.InitableIF

nocode: g_dbus_proxy_new_finish
nocode: g_dbus_proxy_new_for_bus_finish

code: start
	// add the DBusInterface capabilities
	mixin AsyncInitableT!(GDBusProxy);

	// add the DBusInterface capabilities
	mixin DBusInterfaceT!(GDBusProxy);

	// add the Initable capabilities
	mixin InitableT!(GDBusProxy);

	/**
	 * Finishes creating a GDBusProxy.
	 * Since 2.26
	 * Params:
	 *     res    = A GAsyncResult obtained from the GAsyncReadyCallback
	 *              function passed to g_dbus_proxy_new().
	 *     forBus = If true finish an address.
	 * Throws: GException on failure.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (AsyncResultIF res, bool forBus = false)
	{
		// GDBusProxy * g_dbus_proxy_new_finish (GAsyncResult *res,  GError **error);
		GError* err = null;
		GDBusProxy* p;

		if ( forBus )
		{
			p = g_dbus_proxy_new_for_bus_finish((res is null) ? null : res.getAsyncResultTStruct(), &err);
		}
		else
		{
			p = g_dbus_proxy_new_finish((res is null) ? null : res.getAsyncResultTStruct(), &err);
		}
	
		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}
		
		if(p is null)
		{
			throw new ConstructionException("null returned by g_dbus_proxy_new_finish((res is null) ? null : res.getAsyncResultTStruct(), &err)");
		}
		this(cast(GDBusProxy*) p);
	}
code: end
outFile: DBusProxy

file: GDBusObject.html
struct: GDBusObject
class: DBusObjectT
template: TStruct
prefix: g_dbus_interface_
import: glib.Str
import: glib.ListG
import: gio.DBusInterface
import: gio.DBusInterfaceIF
structWrap: GList* ListG
structWrap: GDBusInterface* DBusInterfaceIF
interface: DBusObjectIF
outFile: DBusObjectT

file:
class: DBusObject
extend: ObjectG
implements: DBusObjectIF
import: gobject.ObjectG

# imports for DBusObject Interface
import: gio.DBusObjectT
import: gio.DBusObjectIF

code: start
	// Minimal implementation.
	mixin DBusObjectT!(GDBusObject);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gDBusObject;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GDBusObject* gDBusObject)
	{
		super(cast(GObject*)gDBusObject);
		this.gDBusObject = gDBusObject;
	}
code: end
outFile: DBusObject

file: GDBusObjectSkeleton.html
struct: GDBusObjectSkeleton
class: DBusObjectSkeleton
implements: DBusObjectIF
prefix: g_dbus_object_skeleton_
import: glib.Str
import: gio.DBusInterfaceSkeleton
structWrap: GDBusInterfaceSkeleton* DBusInterfaceSkeleton

# imports for DBusObject Interface
import: gio.DBusObjectT
import: gio.DBusObjectIF

code: start
	// add the DBusObject capabilities
	mixin DBusObjectT!(GDBusObjectSkeleton);
code: end
outFile: DBusObjectSkeleton

file: GDBusObjectProxy.html
struct: GDBusObjectProxy
class: DBusObjectProxy
implements: DBusObjectIF
prefix: g_dbus_object_proxy_
import: glib.Str
import: gio.DBusConnection
structWrap: GDBusConnection* DBusConnection

# imports for DBusObject Interface
import: gio.DBusObjectT
import: gio.DBusObjectIF

code: start
	// add the DBusObject capabilities
	mixin DBusObjectT!(GDBusObjectProxy);
code: end
outFile: DBusObjectProxy

file: GDBusObjectManager.html
struct: GDBusObjectManager
class: DBusObjectManagerT
template: TStruct
prefix: g_dbus_object_manager_
import: glib.Str
import: glib.ListG
import: gio.DBusInterface
import: gio.DBusInterfaceIF
import: gio.DBusObject
import: gio.DBusObjectIF
structWrap: GList* ListG
structWrap: GDBusInterface* DBusInterfaceIF
structWrap: GDBusObject* DBusObjectIF
interface: DBusObjectManagerIF
outFile: DBusObjectManagerT

file: GDBusObjectManagerServer.html
struct: GDBusObjectManagerServer
class: DBusObjectManagerServer
implements: DBusObjectManagerIF
prefix: g_dbus_object_manager_server_
import: glib.Str
import: gio.DBusConnection
import: gio.DBusObjectSkeleton
structWrap: GDBusConnection* DBusConnection
structWrap: GDBusObjectSkeleton* DBusObjectSkeleton

# imports for DBusObjectManager Interface
import: gio.DBusObjectManagerT
import: gio.DBusObjectManagerIF

code: start
	// add the DBusObjectManager capabilities
	mixin DBusObjectManagerT!(GDBusObjectManagerServer);
code: end
outFile: DBusObjectManagerServer

file: GDBusObjectManagerClient.html
struct: GDBusObjectManagerClient
ctorStruct: GDBusObjectManager
class: DBusObjectManagerClient
implements: AsyncInitableIF
implements: DBusObjectManagerIF
implements: InitableIF
prefix: g_dbus_object_manager_client_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
import: gio.DBusConnection
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
structWrap: GDBusConnection* DBusConnection

# imports for AsyncInitable Interface
import: gio.AsyncInitableT
import: gio.AsyncInitableIF

# imports for DBusObjectManager Interface
import: gio.DBusObjectManagerT
import: gio.DBusObjectManagerIF

# imports for Initable Interface
import: gio.InitableT
import: gio.InitableIF

nocode: g_dbus_object_manager_client_new_finish
nocode: g_dbus_object_manager_client_new_for_bus_finish

code: start
	// add the AsyncInitable capabilities
	mixin AsyncInitableT!(GDBusObjectManagerClient);

	// add the DBusObjectManager capabilities
	mixin DBusObjectManagerT!(GDBusObjectManagerClient);

	// add the Initable capabilities
	mixin InitableT!(GDBusObjectManagerClient);

	/**
	 * Finishes an operation started with g_dbus_object_manager_client_new().
	 * Since 2.30
	 * Params:
	 * res = A GAsyncResult obtained from the GAsyncReadyCallback passed to g_dbus_object_manager_client_new().
	 * Throws: GException on failure.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (AsyncResultIF res, bool forBus = false)
	{
		// GDBusObjectManager * g_dbus_object_manager_client_new_finish  (GAsyncResult *res,  GError **error);
		GError* err = null;
		GDBusObjectManager* p;

		if ( forBus )
		{
			p = g_dbus_object_manager_client_new_for_bus_finish((res is null) ? null : res.getAsyncResultTStruct(), &err);
		}
		else
		{
			p = g_dbus_object_manager_client_new_finish((res is null) ? null : res.getAsyncResultTStruct(), &err);
		}

		if (err !is null)
		{
			throw new GException( new ErrorG(err) );
		}
		
		if(p is null)
		{
			throw new ConstructionException("null returned by g_dbus_object_manager_client_new_finish((res is null) ? null : res.getAsyncResultTStruct(), &err)");
		}
		this(cast(GDBusObjectManagerClient*) p);
	}
code: end
outFile: DBusObjectManagerClient

###########################################################
### Settings ##############################################
###########################################################

file: GSettings.html
struct: GSettings
class: Settings
prefix: g_settings_
import: glib.Str
import: glib.Variant
import: glib.VariantType
import: gobject.Value
import: gio.Action
import: gio.ActionIF
import: gio.SettingsBackend
import: gio.SettingsSchema
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType
structWrap: GValue* Value
structWrap: GAction* ActionIF
structWrap: GSettings* Settings
structWrap: GSettingsBackend* SettingsBackend
structWrap: GSettingsSchema* SettingsSchema
array: g_settings_set_strv value
outFile: Settings

file: GSettingsBackend.html
struct: GSettingsBackend
class: SettingsBackend
prefix: g_settings_backend_
prefix: g_
import: glib.Str
import: glib.BBTree
import: glib.Variant
structWrap: GTree* BBTree
structWrap: GVariant* Variant
structWrap: GSettingsBackend* SettingsBackend
out: g_settings_backend_flatten_tree path
out: g_settings_backend_flatten_tree keys
out: g_settings_backend_flatten_tree values
array: g_settings_backend_flatten_tree keys
array: g_settings_backend_flatten_tree values keys.length
outFile: SettingsBackend

file: gio-GSettingsSchema-GSettingsSchemaSource.html
struct: GSettingsSchema
class: SettingsSchema
prefix: g_settings_schema_
noprefix: g_settings_schema_source_
import: glib.Str
import: gtkc.Loader
import: gtkc.paths
structWrap: GSettingsSchema* SettingsSchema

code: start
	~this()
	{
		if ( Linker.isLoaded(LIBRARY.GIO) && gSettingsSchema != null)
		{
			g_settings_schema_unref(gSettingsSchema);
		}
	}
code: end
outFile: SettingsSchema

struct: GSettingsSchemaSource
class: SettingsSchemaSource
prefix: g_settings_schema_source_
strictPrefix: Y
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.SettingsSchema
import: gtkc.paths
import: gtkc.Loader
structWrap: GSettingsSchema* SettingsSchema
structWrap: GSettingsSchemaSource* SettingsSchemaSource

code: start
	~this ()
	{
		if ( Linker.isLoaded(LIBRARY.GTK) && gSettingsSchemaSource !is null )
		{
			g_settings_schema_source_unref(gSettingsSchemaSource);
		}
	}
code: end
outFile: SettingsSchemaSource

###########################################################
### Resources #############################################
###########################################################

file: gio-GResource.html
struct: GResource
class: Resource
prefix: g_permission_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.Bytes
import: gio.InputStream
import: gtkc.Loader
import: gtkc.paths
structWrap: GBytes* Bytes
structWrap: GInputStream* InputStream
structWrap: GResource* Resource

out: g_resource_get_info size
out: g_resource_get_info flags

code: start
	~this()
	{
		if ( Linker.isLoaded(LIBRARY.GIO) && gResource != null)
		{
			g_resource_unref(gResource);
		}
	}
code: end
outFile: Resource

###########################################################
### Permissions ###########################################
###########################################################

file: GPermission.html
struct: GPermission
class: Permission
prefix: g_permission_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.AsyncResultIF
import: gio.Cancellable
structWrap: GAsyncResult* AsyncResultIF
structWrap: GCancellable* Cancellable
outFile: Permission

file: GSimplePermission.html
struct: GSimplePermission
ctorStruct: GPermission
class: SimplePermission
prefix: g_simple_permission_
outFile: SimplePermission

###########################################################
### Application Support ###################################
###########################################################

file: GApplication.html
struct: GApplication
class: Application
implements: ActionGroupIF
implements: ActionMapIF
prefix: g_application_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gio.Cancellable
import: gio.DBusConnection
import: gio.File
structWrap: GApplication* Application
structWrap: GCancellable* Cancellable
structWrap: GDBusConnection* DBusConnection
structWrap: GFile* File

#imports for ActionGroup Interface.
import: gio.ActionGroupIF
import: gio.ActionGroupT

#imports for ActionMap Interface.
import: gio.ActionMapIF
import: gio.ActionMapT

array: g_application_open files n_files
array: g_application_run argv argc

code: start
	// add the ActionGroup capabilities
	mixin ActionGroupT!(GApplication);

	// add the ActionMap capabilities
	mixin ActionMapT!(GApplication);
code: end
outFile: Application

file: GApplicationCommandLine.html
struct: GApplicationCommandLine
class: ApplicationCommandLine
prefix: g_application_command_line_
import: glib.Str
import: glib.Variant
import: gio.File
import: gio.InputStream
structWrap: GVariant* Variant
structWrap: GFile* File
structWrap: GInputStream* InputStream
array: g_application_command_line_get_arguments Return argc
outFile: ApplicationCommandLine

file: GActionGroup.html
struct: GActionGroup
class: ActionGroupT
template: TStruct
prefix: g_action_group_
import: glib.Str
import: glib.Variant
import: glib.VariantType
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType

out: g_action_group_query_action enabled
out: g_action_group_query_action parameter_type
out: g_action_group_query_action state_type
out: g_action_group_query_action state_hint
out: g_action_group_query_action state

interface: ActionGroupIF
outFile: ActionGroupT

file: GActionMap.html
struct: GActionMap
class: ActionMapT
template: TStruct
prefix: g_action_map_
import: glib.Str
import: gio.Action
import: gio.ActionIF
structWrap: GAction* ActionIF
array: g_action_map_add_action_entries entries n_entries
interface: ActionMapIF
outFile: ActionMapT

file: GSimpleActionGroup.html
struct: GSimpleActionGroup
class: SimpleActionGroup
implements: ActionGroupIF
implements: ActionMapIF
prefix: g_simple_action_group_
import: glib.Str
import: gio.Action
import: gio.ActionIF
structWrap: GAction* ActionIF

#imports for ActionGroup Interface.
import: gio.ActionGroupIF
import: gio.ActionGroupT

#imports for ActionMap Interface.
import: gio.ActionMapIF
import: gio.ActionMapT

array: g_simple_action_group_add_entries entries n_entries

code: start
	// add the ActionGroup capabilities
	mixin ActionGroupT!(GSimpleActionGroup);

	// add the ActionMap capabilities
	mixin ActionMapT!(GSimpleActionGroup);
code: end
outFile: SimpleActionGroup

file: GAction.html
struct: GAction
class: ActionT
template: TStruct
prefix: g_action_
import: glib.Str
import: glib.Variant
import: glib.VariantType
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType
interface: ActionIF
outFile: ActionT

file:
class: Action
extend: ObjectG
implements: ActionIF
import: gobject.ObjectG

# imports for Converter Interface
import: gio.ActionT
import: gio.ActionIF

code: start
	// Minimal implementation.
	mixin ActionT!(GAction);

	/** the main Gtk struct as a void* */
	protected override void* getStruct()
	{
		return cast(void*)gAction;
	}
	
	/**
	 * Sets our main struct and passes it to the parent class
	 */
	public this (GAction* gAction)
	{
		super(cast(GObject*)gAction);
		this.gAction = gAction;
	}
code: end
outFile: Action

file: GSimpleAction.html
struct: GSimpleAction
class: SimpleAction
implements: ActionIF
prefix: g_simple_action_
import: glib.Str
import: glib.Variant
import: glib.VariantType
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType

#imports for Action Interface.
import: gio.ActionIF
import: gio.ActionT

code: start
	// add the Action capabilities
	mixin ActionT!(GSimpleAction);
code: end
outFile: SimpleAction

file: GRemoteActionGroup.html
struct: GRemoteActionGroup
class: RemoteActionGroupT
template: TStruct
prefix: g_remote_action_group_
import: glib.Str
import: glib.Variant
structWrap: GVariant* Variant
interface: RemoteActionGroupIF
outFile: RemoteActionGroupT

#file: gio-GActionGroup-exporter.html
#See: GDBusConnection

file: GDBusActionGroup.html
struct: GDBusActionGroup
class: DBusActionGroup
implements: ActionGroupIF
implements: RemoteActionGroupIF
prefix:  g_dbus_action_group_
import: glib.Str
import: gio.DBusConnection
structWrap: GDBusActionGroup* DBusActionGroup
structWrap: GDBusConnection* DBusConnection

#imports for ActionGroup Interface.
import: gio.ActionGroupIF
import: gio.ActionGroupT

#imports for RemoteActionGroup Interface.
import: gio.RemoteActionGroupIF
import: gio.RemoteActionGroupT

code: start
	// add the ActionGroup capabilities
	mixin ActionGroupT!(GDBusActionGroup);

	// add the RemoteActionGroup capabilities
	mixin RemoteActionGroupT!(GDBusActionGroup);

	/**
	 * See_Also: get().
	 */
	this(DBusConnection connection, string busName, string objectPath)
	{
		auto p =  g_dbus_action_group_get((connection is null) ? null : connection.getDBusConnectionStruct(), Str.toStringz(busName), Str.toStringz(objectPath));
		
		if(p is null)
		{
			throw new ConstructionException("null returned by g_dbus_action_group_get");
		}
		this(cast(GDBusActionGroup*) p);
	}
code: end
outFile: DBusActionGroup

file: GMenuModel.html
struct: GMenuModel
class: MenuModel
prefix: g_menu_model_
noprefix: g_menu_attribute_iter_
noprefix: g_menu_link_iter_
import: glib.Str
import: glib.Variant
import: glib.VariantType
import: gio.MenuAttributeIter
import: gio.MenuLinkIter
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType
structWrap: GMenuAttributeIter* MenuAttributeIter
structWrap: GMenuLinkIter* MenuLinkIter
structWrap: GMenuModel* MenuModel
outFile: MenuModel

struct: GMenuAttributeIter
class: MenuAttributeIter
prefix: g_menu_attribute_iter_
strictPrefix: Y
import: glib.Str
import: glib.Variant
structWrap: GVariant* Variant
nosignal: items-changed
out: g_menu_attribute_iter_get_next out_name
out: g_menu_attribute_iter_get_next value
outFile: MenuAttributeIter

struct: GMenuLinkIter
class: MenuLinkIter
prefix: g_menu_link_iter_
strictPrefix: Y
import: glib.Str
import: gio.MenuModel
structWrap: GMenuModel* MenuModel
nosignal: items-changed
out: g_menu_link_iter_get_next out_name
out: g_menu_link_iter_get_next value
outFile: MenuLinkIter

file: GMenu.html
struct: GMenu
class: Menu
prefix: g_menu_
noprefix: g_menu_item_
import: glib.Str
import: gio.MenuItem
import: gio.MenuModel
structWrap: GMenuItem* MenuItem
structWrap: GMenuModel* MenuModel
outFile: Menu

struct: GMenuItem
class: MenuItem
prefix: g_menu_item_
strictPrefix: Y
import: glib.Str
import: glib.Variant
import: glib.VariantType
import: gio.MenuModel
structWrap: GVariant* Variant
structWrap: GVariantType* VariantType
structWrap: GMenuModel* MenuModel

#Use setSection or setSubmenu
nocode: g_menu_item_new_section
nocode: g_menu_item_new_submenu

outFile: MenuItem

#file: gio-GMenuModel-exporter.html
#See: GDBusConnection

file: GDBusMenuModel.html
struct: GDBusMenuModel
class: DBusMenuModel
prefix: g_menu_
import: glib.Str
import: gio.DBusConnection
structWrap: GDBusConnection* DBusConnection
structWrap: GDBusMenuModel* DBusMenuModel

code: start
	/**
	 * See_Also: get().
	 */
	this(DBusConnection connection, string busName, string objectPath)
	{
		auto p =  g_dbus_menu_model_get((connection is null) ? null : connection.getDBusConnectionStruct(), Str.toStringz(busName), Str.toStringz(objectPath));
		
		if(p is null)
		{
			throw new ConstructionException("null returned by g_dbus_menu_model_get");
		}

		this(cast(GDBusMenuModel*) p);
	}
code: end
outFile: DBusMenuModel

###########################################################
### Extending GIO #########################################
###########################################################

file: GVfs.html
struct: GVfs
class: Vfs
prefix: g_vfs_
import: glib.Str
import: gio.File
structWrap: GFile* File
structWrap: GVfs* Vfs
outFile: Vfs

file: GIOModule.html
struct: GIOModule
class: IOModule
prefix: g_io_module_
prefix: g_io_modules_
noprefix: g_io_module_scope_
import: glib.Str
import: glib.ListG
import: gio.IOModuleScope
structWrap: GList* ListG
structWrap: GIOModuleScope* IOModuleScope
outFile: IOModule

struct: GIOModuleScope
class: IOModuleScope
prefix: g_io_module_scope_
strictPrefix: Y
import: glib.Str
import: gtkc.Loader
import: gtkc.paths
structWrap: GIOModuleScope* IOModuleScope

code: start
	~this()
	{
		if ( Linker.isLoaded(LIBRARY.GIO) && gIOModuleScope != null)
		{
			g_io_module_scope_free(gIOModuleScope);
		}
	}
code: end
outFile: IOModuleScope

file: gio-Extension-Points.html
struct: GIOExtension
class: IOExtension
prefix: g_io_extension_
noprefix: g_io_extension_point_
import: glib.Str
structWrap: GIOExtension* IOExtension
outFile: IOExtension

struct: GIOExtensionPoint
class: IOExtensionPoint
prefix: g_io_extension_point_
strictPrefix: Y
import: glib.Str
import: glib.ListG
import: gio.IOExtension
structWrap: GList* ListG
structWrap: GIOExtension* IOExtension
structWrap: GIOExtensionPoint* IOExtensionPoint
outFile: IOExtensionPoint

###########################################################
### GIO Testing ###########################################
###########################################################

file: GTestDBus.html
struct: GTestDBus
class: TestDBus
prefix: g_test_dbus_
import: glib.Str
outFile: TestDBus

