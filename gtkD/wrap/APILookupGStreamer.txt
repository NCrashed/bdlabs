#
# This file is part of gstreamerD.
#
# gstreamerD is free software; you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License
# as published by the Free Software Foundation; either version 3
# of the License, or (at your option) any later version, with
# some exceptions, please read the COPYING file.
#
# gstreamerD is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with gstreamerD; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110, USA
#


#
###
#####
# Definitions for wrapping GStreamer
#####
###
#

enumType: GST_ELEMENT_FLAG_LAST GstElementFlags.LAST
enumType: GST_OBJECT_FLAG_LAST GstObjectFlags.LAST
enumType: GST_MINI_OBJECT_FLAG_LOCK_READONLY GstMiniObjectFlags.LOCK_READONLY
enumType: GST_MINI_OBJECT_FLAG_LAST GstMiniObjectFlags.LAST
enumType: GST_LOCK_FLAG_READ GstLockFlags.READ
enumType: GST_LOCK_FLAG_WRITE GstLockFlags.WRITE
enumType: GST_STATE_NULL GstState.NULL
enumType: GST_STATE_READY GstState.READY
enumType: GST_STATE_PAUSED GstState.PAUSED
enumType: GST_STATE_PLAYING GstState.PLAYING
enumType: FLAG_LAST GstBinFlags.FLAG_LAST
enumType: GST_SEEK_FLAG_NONE GstSeekFlags.NONE
enumType: GST_SEEK_FLAG_FLUSH GstSeekFlags.FLUSH
enumType: GST_SEEK_FLAG_SKIP GstSeekFlags.SKIP
enumType: GST_SEEK_FLAG_SEGMENT GstSeekFlags.SEGMENT

alias: GST_SEEK_TYPE_NONE NONE
alias: GST_SEEK_TYPE_SET SET
alias: GST_SEEK_TYPE_END END
alias: GST_BIN_FLAG_LAST FLAG_LAST

alias: GStaticRecMutex void
alias: GstXmlNodePtr void*
alias: xmlNodePtr void*

addTypedefs: start
public import gtkc.glibtypes;
public import gtkc.gthreadtypes;
public import gtkc.gobjecttypes;
addTypedefs: end

addAliases: start
	alias void GStaticRecMutex;
	alias void* GstXmlNodePtr;
	alias void* xmlNodePtr;
addAliases: end

addEnums: start
	/**
	 * GstEventTypeFlags indicate the aspects of the different GstEventType
	 * values. You can get the type flags of a GstEventType with the
	 * gst_event_type_get_flags() function.
	 * GST_EVENT_TYPE_UPSTREAM
	 */
	public enum GstEventTypeFlags
	{
		UPSTREAM     = 1 << 0,
		DOWNSTREAM   = 1 << 1,
		SERIALIZED   = 1 << 2,
		STICKY       = 1 << 3,
		STICKY_MULTI = 1 << 4,
	}
	alias GstEventTypeFlags EventTypeFlags;

	/**
	 * GstEventType lists the standard event types that can be sent in a pipeline.
	 * The custom event types can be used for private messages between elements
	 * that can't be expressed using normal
	 * GStreamer buffer passing semantics. Custom events carry an arbitrary
	 * GstStructure.
	 * Specific custom events are distinguished by the name of the structure.
	 * GST_EVENT_UNKNOWN
	 */
	public enum GstEventType
	{
		UNKNOWN = 0,

		/+* bidirectional events +/
		FLUSH_START = (10 << 8) | GstEventTypeFlags.UPSTREAM | GstEventTypeFlags.DOWNSTREAM,
		FLUSH_STOP  = (20 << 8) | GstEventTypeFlags.UPSTREAM | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED,

		/+* downstream serialized events +/
		STREAM_START = (  40 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY,
		CAPS         = (  50 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY,
		SEGMENT      = (  70 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY,
		TAG          = (  80 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY | GstEventTypeFlags.STICKY_MULTI,
		BUFFERSIZE   = (  90 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY,
		SINK_MESSAGE = ( 100 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY | GstEventTypeFlags.STICKY_MULTI,
		EOS          = ( 110 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY,
		TOC          = ( 120 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY | GstEventTypeFlags.STICKY_MULTI,

		/* non-sticky downstream serialized */
		SEGMENT_DONE = ( 150 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED,
		GAP          = ( 160 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED,

		/+* upstream events +/
		QOS         = ( 190 << 8 ) | GstEventTypeFlags.UPSTREAM,
		SEEK        = ( 200 << 8 ) | GstEventTypeFlags.UPSTREAM,
		NAVIGATION  = ( 210 << 8 ) | GstEventTypeFlags.UPSTREAM,
		LATENCY     = ( 220 << 8 ) | GstEventTypeFlags.UPSTREAM,
		STEP        = ( 230 << 8 ) | GstEventTypeFlags.UPSTREAM,
		RECONFIGURE = ( 240 << 8 ) | GstEventTypeFlags.UPSTREAM,
		TOC_SELECT  = ( 250 << 8 ) | GstEventTypeFlags.UPSTREAM,

		/+* custom events start here +/
		CUSTOM_UPSTREAM          = ( 270 << 8 ) | GstEventTypeFlags.UPSTREAM,
		CUSTOM_DOWNSTREAM        = ( 280 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED,
		CUSTOM_DOWNSTREAM_OOB    = ( 290 << 8 ) | GstEventTypeFlags.DOWNSTREAM,
		CUSTOM_DOWNSTREAM_STICKY = ( 300 << 8 ) | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED | GstEventTypeFlags.STICKY | GstEventTypeFlags.STICKY_MULTI,
		CUSTOM_BOTH              = ( 310 << 8 ) | GstEventTypeFlags.UPSTREAM | GstEventTypeFlags.DOWNSTREAM | GstEventTypeFlags.SERIALIZED,
		CUSTOM_BOTH_OOB          = ( 320 << 8 ) | GstEventTypeFlags.UPSTREAM | GstEventTypeFlags.DOWNSTREAM
	}
	alias GstEventType EventType;

	public enum GstQueryType
	{
		UNKNOWN     = (0 << 8)   | 0,
		POSITION    = (10 << 8)  | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		DURATION    = (20 << 8)  | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		LATENCY     = (30 << 8)  | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		JITTER      = (40 << 8)  | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		RATE        = (50 << 8)  | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		SEEKING     = (60 << 8)  | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		SEGMENT     = (70 << 8)  | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		CONVERT     = (80 << 8)  | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		FORMATS     = (90 << 8)  | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		BUFFERING   = (110 << 8) | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		CUSTOM      = (120 << 8) | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		URI         = (130 << 8) | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		ALLOCATION  = (140 << 8) | GstQueryTypeFlags.DOWNSTREAM | GstQueryTypeFlags.SERIALIZED,
		SCHEDULING  = (150 << 8) | GstQueryTypeFlags.UPSTREAM,
		ACCEPT_CAPS = (160 << 8) | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		CAPS        = (170 << 8) | (GstQueryTypeFlags.UPSTREAM | GstQueryTypeFlags.DOWNSTREAM),
		DRAIN       = (180 << 8) | GstQueryTypeFlags.DOWNSTREAM | GstQueryTypeFlags.SERIALIZED,
	}
	alias GstQueryType QueryType;
addEnums: end

addStructs: start
	struct GstBinPrivate{}

	public struct GstBuffer
	{
		GstMiniObject  mini_object;

		/*< public >*/ /* with COW */
		GstBufferPool* pool;

		/* timestamp */
		GstClockTime   pts;
		GstClockTime   dts;
		GstClockTime   duration;

		/* media specific offset */
		guint64        offset;
		guint64        offset_end;
	}

	public struct GstObjectClass
	{
		GInitiallyUnownedClass parent_class;

		const gchar* path_string_separator;

		/* signals */
		extern(C) void function(GstObject* object, GstObject* orig, GParamSpec* pspec) deep_notify;

		/*< public >*/
		/* virtual methods for subclasses */

		/*< private >*/
		gpointer _gst_reserved[GST_PADDING];
	}

	struct GstMessage
	{
		GstMiniObject   mini_object;

		/*< public > *//* with COW */
		GstMessageType  type;
		guint64         timestamp;
		GstObject*      src;
		guint32         seqnum;

		/*< private >*//* with MESSAGE_LOCK */
		GMutex          lock;                 /* lock and cond for async delivery */
		GCond           cond;
	}

	public struct GstMiniObject
	{
		GType   type;

		/*< public >*/ /* with COW */
		gint    refcount;
		gint    lockstate;
		guint   flags;

		extern(C) GstMiniObject* function(GstMiniObject* obj) copy;
		extern(C) gboolean       function(GstMiniObject* obj) dispose;
		extern(C) void           function(GstMiniObject* obj) free;

		/* < private > */
		/* Used to keep track of weak ref notifies and qdata */
		guint n_qdata;
		gpointer qdata;
	}
addStructs: end

addTypes: start
addTypes: end

addFuncts: start
addFuncts: end

addUnions: start
addUnions: end

addConstants: start
	/***** default padding of structures *****/
	const long GST_PADDING = 4;

	/***** padding for very extensible base classes *****/
	const long GST_PADDING_LARGE = 20;

	//These times might be clean to define as GstClockTimes instead of long (maybe):

	//#define G_USEC_PER_SEC 1000000 //This should be in glib...
	const ulong G_USEC_PER_SEC = 1000000uL;
	//#define GST_SECOND  (G_USEC_PER_SEC * G_GINT64_CONSTANT (1000))
	const ulong GST_SECOND = (G_USEC_PER_SEC * 1000uL);

	public alias GST_SECOND SECOND;

	//This one is an undefined GstClockTime. How can this be ulong???
	//I guess it should be long...???
	//#define GST_CLOCK_TIME_NONE		((GstClockTime) -1)
	const long GST_CLOCK_TIME_NONE = -1L;
	public alias GST_CLOCK_TIME_NONE CLOCK_TIME_NONE;
addConstants: end

# must start with wrap

wrap: gstreamer
srcout: srcgstreamer

###########################################################
### GStreamer #############################################
###########################################################

file: gstreamer-Gst.html
class: GStreamer
prefix: gst_
import: glib.ErrorG
import: glib.GException
import: glib.Str
import: glib.OptionGroup
structWrap: GOptionGroup* OptionGroup

inout: gst_version major
inout: gst_version minor
inout: gst_version micro
inout: gst_version nano
inout: gst_init argv
array: gst_init argv argc
inout: gst_init_check argv
array: gst_init_check argv argc
outFile: gstreamer

file: GstAllocator.html
struct: GstAllocator
class: Allocator
prefix: gst_allocator_
import: glib.Str
import: gstreamer.Memory
structWrap: GstAllocator* Allocator
structWrap: GstMemory* Memory
outFile: Allocator

file: gstreamer-GstAtomicQueue.html
struct: GstAtomicQueue
class: AtomicQueue
prefix: gst_atomic_queue_
outFile: AtomicQueue

file: GstBin.html
struct: GstBin
ctorStruct: GstElement
class: Bin
prefix: gst_bin_
import: glib.Str
import: gstreamer.Element
import: gstreamer.Iterator
import: gstreamer.Pad
structWrap: GstElement* Element
structWrap: GstIterator* Iterator
structWrap: GstPad* Pad

code: start
	/** */
	public this(Element elem)
	{
		super( elem.getElementStruct() );
		this.gstBin = cast(GstBin*)elem.getElementStruct();
	}
code: end
outFile: Bin

file: gstreamer-GstBuffer.html
struct: GstBuffer
nostruct: GstBuffer
class: Buffer
prefix: gst_buffer_
import: glib.Str
import: gstreamer.Allocator
import: gstreamer.Memory
import: gstreamer.Meta
structWrap: GstAllocator* Allocator
structWrap: GstBuffer* Buffer
structWrap: GstMemory* Memory

array: gst_buffer_new_wrapped data size
out: gst_buffer_get_sizes offset
out: gst_buffer_get_sizes maxsize
out: gst_buffer_get_sizes_range offset
out: gst_buffer_get_sizes_range maxsize
out: gst_buffer_find_memory idx
out: gst_buffer_find_memory length
out: gst_buffer_find_memory skip
out: gst_buffer_map info
out: gst_buffer_map_range info
inout: gst_buffer_unmap info
array: gst_buffer_memcmp mem size
array: gst_buffer_extract dest size
array: gst_buffer_fill src size
inout: gst_buffer_replace obuf
outFile: Buffer

file: gstreamer-GstBufferList.html
struct: GstBufferList
class: BufferList
prefix: gst_buffer_list_
import: gstreamer.Buffer
structWrap: GstBuffer* Buffer
structWrap: GstBufferList* BufferList
outFile: BufferList

file: gstreamer-GstBufferPool.html
struct: GstBufferPool
class: BufferPool
prefix: gst_buffer_pool_
import: glib.Str
import: gstreamer.Allocator
import: gstreamer.Buffer
import: gstreamer.Caps
import: gstreamer.Structure
structWrap: GstAllocator* Allocator
structWrap: GstBuffer* Buffer
structWrap: GstCaps* Caps
structWrap: GstStructure* Structure

out: gst_buffer_pool_config_get_params caps
out: gst_buffer_pool_config_get_params size
out: gst_buffer_pool_config_get_params min_buffers
out: gst_buffer_pool_config_get_params max_buffers
inout: gst_buffer_pool_config_get_allocator allocator
out: gst_buffer_pool_acquire_buffer buffer
outFile: BufferPool

file: GstBus.html
struct: GstBus
class: Bus
prefix: gst_bus_
import: glib.Str
import: glib.Source
import: gstreamer.Message
structWrap: GSource* Source
structWrap: GstBus* Bus
structWrap: GstMessage* Message

nocode: gst_bus_add_watch
nocode: gst_bus_set_sync_handler
code: start
	/**
	 * Adds a bus watch to the default main context with the default priority.
	 * This function is used to receive asynchronous messages in the main loop.
	 * The watch can be removed using g_source_remove() or by returning FALSE
	 * from func.
	 * MT safe.
	 * Params:
	 *  dlg = A function to call when a message is received.
	 * Returns:
	 *  The event source id.
	 */
	public uint addWatch( bool delegate(Message) dlg )
	{
		onWatchListener = dlg;
		return gst_bus_add_watch(gstBus, cast(GstBusFunc)&watchCallBack, cast(void*)this);
	}

	bool delegate(Message) onWatchListener;

	extern(C) static gboolean watchCallBack(GstBus* bus, GstMessage* msg, Bus bus_d )//gpointer data)
	{
		Message msg_d = new Message( msg );

		return bus_d.onWatchListener( msg_d );
	}
	
	 /**
	  * Use this for making an XOverlay.
	  * Sets the synchronous handler on the bus. The function will be called
	  * every time a new message is posted on the bus. Note that the function
	  * will be called in the same thread context as the posting object. This
	  * function is usually only called by the creator of the bus. Applications
	  * should handle messages asynchronously using the gst_bus watch and poll
	  * functions.
	  * You cannot replace an existing sync_handler. You can pass NULL to this
	  * function, which will clear the existing handler.
	  * Params:
	  *  dlg = The handler function to install
	  */
	public void setSyncHandler( GstBusSyncReply delegate(Message) dlg )
	{
		onSyncHandlerListener = dlg;
		gst_bus_set_sync_handler(gstBus, cast(GstBusSyncHandler)&syncHandlerCallBack, cast(void*)this, null);
	}
	
	GstBusSyncReply delegate(Message) onSyncHandlerListener;
	
	extern(C) static GstBusSyncReply syncHandlerCallBack(GstBus* bus, GstMessage* msg, Bus bus_d)
	{
		Message msg_d = new Message( msg );
		
		return bus_d.onSyncHandlerListener( msg_d );
	}
code: end
outFile: Bus

file: gstreamer-GstCaps.html
struct: GstCaps
class: Caps
prefix: gst_caps_
prefix: gst_
override: toString
import: glib.Str
import: gobject.Value
import: gstreamer.Structure
structWrap: GValue* Value
structWrap: GstCaps* Caps
structWrap: GstStructure* Structure

inout: gst_caps_replace caps

nocode: gst_caps_new_any

code: start
	/**
	 * Creates a new GstCaps that indicates that it is compatible with
	 * any media format.
	 * Returns:
	 *  the new GstCaps
	 */
	public static Caps newAny()
	{
		// GstCaps* gst_caps_new_any (void);
		auto p = cast(GstCaps*)gst_caps_new_any();

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_caps_new_any");
		}

		return new Caps(cast(GstCaps*)p );
	}
code: end
outFile: Caps

file: gstreamer-GstSample.html
struct: GstSample
class: Sample
prefix: gst_sample_
import: gstreamer.Buffer
import: gstreamer.Caps
import: gstreamer.Segment
import: gstreamer.Structure
structWrap: GstBuffer* Buffer
structWrap: GstCaps* Caps
structWrap: GstSample* Sample
structWrap: GstSegment* Segment
structWrap: GstStructure* Structure
outFile: Sample

file: GstChildProxy.html
struct: GstChildProxy
class: ChildProxyT
template: TStruct
prefix: gst_child_proxy_
import: glib.Str
import: gobject.ObjectG
import: gobject.ParamSpec
import: gobject.Value
structWrap: GObject* ObjectG
structWrap: GParamSpec* ParamSpec
structWrap: GValue* Value

out: gst_child_proxy_lookup target
out: gst_child_proxy_lookup pspec
interface: ChildProxyIF
outFile: ChildProxyT

file: GstClock.html
struct: GstClock
class: Clock
prefix: gst_clock_
import: glib.Str
structWrap: GstClock* Clock

out: gst_clock_add_observation r_squared
out: gst_clock_get_calibration internal
out: gst_clock_get_calibration external
out: gst_clock_get_calibration rate_num
out: gst_clock_get_calibration rate_denom
inout: gst_clock_id_wait jitter
outFile: Clock

#file: gstreamer-gstconfig.html

file: GstControlBinding.html
struct: GstControlBinding
class: ControlBinding
prefix: gst_control_binding_
import: gobject.Value
import: gstreamer.ObjectGst
structWrap: GValue* Value
structWrap: GstObject* ObjectGst

array: gst_control_binding_get_value_array values n_values
array: gst_control_binding_get_g_value_array values n_values
outFile: ControlBinding

file: GstControlSource.html
struct: GstControlSource
class: ControlSource
prefix: gst_control_source_
out: gst_control_source_get_value value
array: gst_control_source_get_value_array values n_values
outFile: ControlSource

file: gstreamer-GstDateTime.html
struct: GstDateTime
class: DateTime
prefix: gst_date_time_
import: glib.Str
#import: glib.DateTime
import: gstreamer.DateTime
#structWrap: GDateTime* DateTime
structWrap: GstDateTime* DateTime

nocode: gst_date_time_new_now_utc
nocode: gst_date_time_new_now_local_time
nocode: gst_date_time_new_from_unix_epoch_utc
nocode: gst_date_time_new_from_unix_epoch_local_time

code: start
	/**
	 * Creates a new GstDateTime representing the current date and time.
	 * 
	 * Params:
	 *     utc  = If true use utc else use the local timezone.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (bool utc)
	{
		GstDateTime* p;

		if ( utc )
		{
			p = gst_date_time_new_now_utc();
		}
		else
		{
			p = gst_date_time_new_now_local_time();
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_date_time_new_now_local_time()");
		}
		this(cast(GstDateTime*) p);
	}

	/**
	 * Creates a new GstDateTime using the time since Jan 1, 1970 specified by
	 * secs.
	 * 
	 * Params:
	 *     secs = Seconds from the Unix epoch
	 *     utc  = If true use utc else use the local timezone.
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public this (long secs, bool utc)
	{
		GstDateTime* p;

		if ( utc )
		{
			p = gst_date_time_new_from_unix_epoch_utc(secs);
		}
		else
		{
			p = gst_date_time_new_from_unix_epoch_local_time(secs);
		}

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_date_time_new_from_unix_epoch_local_time(secs)");
		}
		this(cast(GstDateTime*) p);
	}
code: end
outFile: DateTime

file: GstElement.html
struct: GstElement
class: Element
prefix: gst_element_
import: gtkc.gobject
import: glib.Str
import: glib.ListG
import: gobject.Type
import: gstreamer.Bus
import: gstreamer.Caps
import: gstreamer.Clock
import: gstreamer.ElementFactory
import: gstreamer.Event
import: gstreamer.Iterator
import: gstreamer.Message
import: gstreamer.Pad
import: gstreamer.PadTemplate
import: gstreamer.Query
structWrap: GList ListG
structWrap: GstBus* Bus
structWrap: GstCaps* Caps
structWrap: GstClock* Clock
structWrap: GstElement* Element
structWrap: GstElementFactory* ElementFactory
structWrap: GstEvent* Event
structWrap: GstIterator* Iterator
structWrap: GstMessage* Message
structWrap: GstPad* Pad
structWrap: GstPadTemplate* PadTemplate
structWrap: GstQuery* Query

out: gst_element_get_state state
out: gst_element_get_state pending
out: gst_element_query_convert dest_val
inout: gst_element_query_position cur
inout: gst_element_query_duration duration

code: start
	/**
	 * Queries an element for the stream position.
	 * This is a convenience function for gstreamerD.
	 * Returns:
	 *  The current position in nanoseconds - GstFormat.TIME.
	 */
	public long queryPosition()
	{
		GstFormat form = GstFormat.TIME;
		long cur_pos;
		queryPosition( form, cur_pos );
		return cur_pos;
	}

	/**
	 * Queries an element for the stream duration.
	 * This is a convenience function for gstreamerD.
	 * Returns:
	 *  The duration in nanoseconds - GstFormat.TIME.
	 */
	public long queryDuration()
	{
		GstFormat form = GstFormat.TIME;
		long cur_dur;
		queryDuration( form, cur_dur );
		return cur_dur;
	}

	/**
	 *	This set's the filename for a filesrc element.
	 */
	public void location( string set )
	{
		//g_object_set( G_OBJECT(getElementStruct()), "location", set, NULL);
		setProperty("location", set);
	}

	/**
	 * Set the caps property of an Element.
	 */
	void caps( Caps cp )
	{
		g_object_set( getElementStruct(), Str.toStringz("caps"), cp.getCapsStruct(), null );
	}

	/**
	* For your convenience in gstreamerD: you can seek to the
	* position of the pipeline measured in time_nanoseconds.
	*/
	public int seek( long time_nanoseconds ) //gint64
	{
		return seek( 1.0, GstFormat.TIME, GstSeekFlags.FLUSH,
								GstSeekType.SET, time_nanoseconds,
								GstSeekType.NONE, GST_CLOCK_TIME_NONE);
	}

	/**
	* Get's all the pads from an element in a Pad[].
	*/
	public Pad[] pads()
	{
		Pad[] result;
		GValue* pad = g_value_init(new GValue(), Type.fromName("GstPad"));
		GstIterator* iter = gst_element_iterate_pads(gstElement);

		while ( gst_iterator_next(iter, pad) == GstIteratorResult.OK )
		{
			result ~= new Pad(cast(GstPad*)g_value_get_object(pad));
			g_value_reset(pad);
		}

		g_value_unset(pad);

		return result;
	}
code: end
outFile: Element

file: GstElementFactory.html
struct: GstElementFactory
class: ElementFactory
prefix: gst_element_factory_
prefix: gst_element_
import: glib.Str
import: glib.ListG
import: gstreamer.Caps
import: gstreamer.Element
import: gstreamer.Plugin
structWrap: GList* ListG
structWrap: GstCaps* Caps
structWrap: GstElement* Element
structWrap: GstElementFactory* ElementFactory
structWrap: GstPlugin* Plugin

code: start
	/**
	 * Create a new element of the type defined by the given element factory.
	 * The element will receive a guaranteed unique name,
	 * consisting of the element factory name and a number.
	 * Params:
	 *  factoryname = a named factory to instantiate
	 * Returns:
	 *  new GstElement or NULL if unable to create element
	 */
	public static Element make( string factoryname )
	{
		// GstElement* gst_element_factory_make (const gchar *factoryname,  const gchar *name);
		auto p = gst_element_factory_make(Str.toStringz(factoryname), null );

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_element_factory_make");
		}

		return new Element( p );
	}
code: end
outFile: ElementFactory

file: gstreamer-GstGError.html
prefix: gst_
import: glib.Str
outFile: GError

file: gstreamer-GstEvent.html
struct: GstEvent
class: Event
prefix: gst_event_
import: glib.Str
import: gstreamer.Caps
import: gstreamer.Message
import: gstreamer.Segment
import: gstreamer.Structure
import: gstreamer.TagList
import: gstreamer.Toc
structWrap: GstCaps* Caps
structWrap: GstEvent* Event
structWrap: GstMessage* Message
structWrap: GstSegment* Segment
structWrap: GstStructure* Structure
structWrap: GstTagList* TagList
structWrap: GstToc* Toc

inout: gst_event_replace old_event
inout: gst_event_steal old_event
inout: gst_event_take old_event
out: gst_event_parse_flush_stop reset_time
out: gst_event_parse_gap timestamp
out: gst_event_parse_gap duration
out: gst_event_parse_stream_start stream_id
out: gst_event_parse_segment segment
out: gst_event_parse_tag taglist
out: gst_event_parse_buffer_size format
out: gst_event_parse_buffer_size minsize
out: gst_event_parse_buffer_size maxsize
out: gst_event_parse_buffer_size async
out: gst_event_parse_qos type
out: gst_event_parse_qos proportion
out: gst_event_parse_qos diff
out: gst_event_parse_qos timestamp
out: gst_event_parse_seek rate
out: gst_event_parse_seek format
out: gst_event_parse_seek flags
out: gst_event_parse_seek start_type
out: gst_event_parse_seek start
out: gst_event_parse_seek stop_type
out: gst_event_parse_seek stop
inout: gst_event_parse_latency latency
out: gst_event_parse_step format
out: gst_event_parse_step amount
out: gst_event_parse_step rate
out: gst_event_parse_step flush
out: gst_event_parse_step intermediate
out: gst_event_parse_sink_message msg
out: gst_event_parse_caps caps
out: gst_event_parse_toc toc
out: gst_event_parse_toc updated
out: gst_event_parse_toc_select uid
out: gst_event_parse_segment_done format
out: gst_event_parse_segment_done position

nocode: gst_event_new_eos
code: start
	/**
	 * Create a new EOS event. The eos event can only travel downstream
	 * synchronized with the buffer flow. Elements that receive the EOS
	 * event on a pad can return UNEXPECTED as a GstFlowReturn when data
	 * after the EOS event arrives.
	 * The EOS event will travel down to the sink elements in the pipeline
	 * which will then post the GST_MESSAGE_EOS on the bus after they have
	 * finished playing any buffered data.
	 * When all sinks have posted an EOS message, the EOS message is
	 * forwarded to the application.
	 * Returns:
	 *  The new EOS event.
	 */
	public static Event newEOS()
	{
		// GstEvent* gst_event_new_eos (void);
		auto p = gst_event_new_eos();

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_event_new_eos");
		}

		return new Event(cast(GstEvent*)p );
	}
code: end
nocode: gst_event_new_flush_start
code: start
	/**
	 * Allocate a new flush start event. The flush start event can be send
	 * upstream and downstream and travels out-of-bounds with the dataflow.
	 * It marks pads as being in a WRONG_STATE to process more data.
	 * Elements unlock and blocking functions and exit their streaming functions
	 * as fast as possible.
	 * This event is typically generated after a seek to minimize the latency
	 * after the seek.
	 * Returns:
	 *  A new flush start event.
	 */
	public static Event newFlushStart()
	{
		// GstEvent* gst_event_new_flush_start (void);
		auto p = gst_event_new_flush_start();

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_event_new_flush_start");
		}

		return new Event(cast(GstEvent*)p );
	}
code: end
nocode: gst_event_new_toc_select
code: start
	/**
	 * Generate a TOC select event with the given uid. The purpose of the
	 * TOC select event is to start playback based on the TOC's entry with
	 * the given uid.
	 */
	public static Event newTocSelect(string uid)
	{
		// GstEvent* gst_event_new_toc_select (const gchar *uid);
		auto p = gst_event_new_toc_select(cast(char*)uid.ptr);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_event_new_toc_select");
		}

		return new Event(cast(GstEvent*)p );
	}
code: end
outFile: Event

file: gstreamer-GstFormat.html
prefix: gst_format_
import: glib.Str
import: gstreamer.Iterator
structWrap: GstIterator* Iterator
array: gst_formats_contains formats
outFile: Format

file: GstGhostPad.html
struct: GstGhostPad
ctorStruct: GstPad
class: GhostPad
prefix: gst_ghost_pad_
noprefix: gst_proxy_pad_
import: glib.Str
import: gstreamer.ObjectGst
import: gstreamer.Pad
import: gstreamer.PadTemplate
structWrap: GstObject* ObjectGst
structWrap: GstPad* Pad
structWrap: GstPadTemplate* PadTemplate
outFile: GhostPad

struct: GstPad
realStruct: GstProxyPad
class: ProxyPad
prefix: gst_proxy_pad_
strictPrefix: Y
override: iterateInternalLinksDefault
import: glib.Str
import: gstreamer.Buffer
import: gstreamer.BufferList
import: gstreamer.Iterator
import: gstreamer.ObjectGst
import: gstreamer.Pad
structWrap: GstBuffer* Buffer
structWrap: GstBufferList* BufferList
structWrap: GstIterator* Iterator
structWrap: GstObject* ObjectGst
structWrap: GstPad* Pad
structWrap: GstProxyPad* ProxyPad

out: gst_proxy_pad_getrange_default buffer

nocode: gst_proxy_pad_get_internal

code: start
	/**
	 * Get the internal pad of pad. Unref target pad after usage.
	 * The internal pad of a GstGhostPad is the internally used
	 * pad of opposite direction, which is used to link to the target.
	 * 
	 * Params:
	 *     pad = the GstProxyPad
	 * Returns: the target GstProxyPad, can be NULL. Unref target pad after usage. [transfer full]
	 */
	public ProxyPad getInternal()
	{
		// GstProxyPad * gst_proxy_pad_get_internal (GstProxyPad *pad);
		auto p = gst_proxy_pad_get_internal(gstProxyPad);
		
		if(p is null)
		{
			return null;
		}
		
		return ObjectG.getDObject!(ProxyPad)(cast(GstProxyPad*) p);
	}
code: end
outFile: ProxyPad

file: gstreamer-GstIterator.html
struct: GstIterator
class: Iterator
prefix: gst_iterator_
import: glib.ListG
import: gthread.Mutex
import: gobject.ObjectG
import: gobject.Value
structWrap: GList* ListG
structWrap: GMutex* Mutex
structWrap: GObject* ObjectG
structWrap: GValue* Value
structWrap: GstIterator* Iterator

inout: gst_iterator_new master_cookie
inout: gst_iterator_new_list list
outFile: Iterator

file: gstreamer-GstMemory.html
struct: GstMemory
class: Memory
prefix: gst_memory_
import: gstreamer.Allocator
import: gstreamer.Memory
structWrap: GstAllocator* Allocator
structWrap: GstMemory* Memory

inout: gst_memory_get_sizes offset
inout: gst_memory_get_sizes maxsize
out: gst_memory_make_mapped info
out: gst_memory_map info
inout: gst_memory_unmap info
out: gst_memory_is_span offset
outFile: Memory

file: gstreamer-GstMessage.html
struct: GstMessage
nostruct: GstMessage
class: Message
prefix: gst_message_
import: glib.Str
import: glib.ErrorG
import: gobject.Value
import: gstreamer.Clock
import: gstreamer.Element
import: gstreamer.ObjectGst
import: gstreamer.Structure
import: gstreamer.TagList
import: gstreamer.Toc
structWrap: GError* ErrorG
structWrap: GValue* Value
structWrap: GstClock* Clock
structWrap: GstElement* Element
structWrap: GstMessage* Message
structWrap: GstObject* ObjectGst
structWrap: GstStructure* Structure
structWrap: GstTagList* TagList
structWrap: GstToc* Toc

inout: gst_message_replace old_message
out: gst_message_parse_error gerror
out: gst_message_parse_error debug
out: gst_message_parse_warning gerror
out: gst_message_parse_warning debug
out: gst_message_parse_info gerror
out: gst_message_parse_info debug
out: gst_message_parse_tag tag_list
out: gst_message_parse_buffering percent
out: gst_message_parse_buffering_stats mode
out: gst_message_parse_buffering_stats avg_in
out: gst_message_parse_buffering_stats avg_out
out: gst_message_parse_buffering_stats buffering_left
out: gst_message_parse_state_changed oldstate
out: gst_message_parse_state_changed newstate
out: gst_message_parse_state_changed pending
out: gst_message_parse_step_done format
out: gst_message_parse_step_done amount
out: gst_message_parse_step_done rate
out: gst_message_parse_step_done flush
out: gst_message_parse_step_done intermediate
out: gst_message_parse_step_done duration
out: gst_message_parse_step_done eos
out: gst_message_parse_clock_provide clock
out: gst_message_parse_clock_provide ready
out: gst_message_parse_clock_lost clock
out: gst_message_parse_new_clock clock
out: gst_message_parse_segment_start format
out: gst_message_parse_segment_start position
out: gst_message_parse_segment_done format
out: gst_message_parse_segment_done position
out: gst_message_parse_async_done running_time
out: gst_message_parse_step_start active
out: gst_message_parse_step_start format
out: gst_message_parse_step_start amount
out: gst_message_parse_step_start rate
out: gst_message_parse_step_start flush
out: gst_message_parse_step_start intermediate
out: gst_message_parse_qos live
out: gst_message_parse_qos rinning_time
out: gst_message_parse_qos stream_time
out: gst_message_parse_qos timestamp
out: gst_message_parse_qos duration
out: gst_message_parse_qos_values jitter
out: gst_message_parse_qos_values proportion
out: gst_message_parse_qos_values quality
out: gst_message_parse_qos_stats format
out: gst_message_parse_qos_stats processed
out: gst_message_parse_qos_stats dropped
out: gst_message_parse_toc toc
out: gst_message_parse_toc updated
out: gst_message_parse_structure_change type
out: gst_message_parse_structure_change owner
out: gst_message_parse_structure_change busy
out: gst_message_parse_request_state state
out: gst_message_parse_stream_status type
out: gst_message_parse_stream_status owner
out: gst_message_parse_progress type
out: gst_message_parse_progress code
out: gst_message_parse_progress text

#TODO: use the messagetype enum to consolidate the constructors.

nocode: gst_message_parse_tag
nocode: gst_message_new_element
nocode: gst_message_new_new_clock
nocode: gst_message_new_segment_done
nocode: gst_message_new_segment_start
nocode: gst_message_new_warning
nocode: gst_message_new_state_dirty
nocode: gst_message_new_eos
nocode: gst_message_new_error
nocode: gst_message_new_info
nocode: gst_message_new_latency
nocode: gst_message_new_duration_changed
nocode: gst_message_new_async_start
nocode: gst_message_new_reset_time

code: start
	/**
	* Get the type of the message.
	*/
	public GstMessageType type()
	{
		return cast(GstMessageType)getMessageStruct().type;
	}
	
	/**
	 * Get the src (the element that originated the message) of the message.
	 */
	public ObjectGst src()
	{
		return new ObjectGst( cast(GstObject*)getMessageStruct().src );
	}

	/**
	 * Create a new element-specific message. This is meant as a generic way of
	 * allowing one-way communication from an element to an application, for example
	 * "the firewire cable was unplugged". The format of the message should be
	 * documented in the element's documentation. The structure field can be NULL.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 *  structure = The structure for the message. The message will take ownership of
	 *  the structure.
	 * Returns:
	 *  The new element message.
	 */
	public static Message newElement(ObjectGst src, Structure structure)
	{
		// GstMessage* gst_message_new_element (GstObject *src,  GstStructure *structure);
		auto p = gst_message_new_element((src is null) ? null : src.getObjectGstStruct(), (structure is null) ? null : structure.getStructureStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_element");
		}

		return new Message(cast(GstMessage*)p);
	}

	/**
	 * Create a new clock message. This message is posted whenever the
	 * pipeline selectes a new clock for the pipeline.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 *  clock = the new selected clock
	 * Returns:
	 *  The new new clock message.
	 */
	public static Message newNewClock(ObjectGst src, Clock clock)
	{
		// GstMessage* gst_message_new_new_clock (GstObject *src,  GstClock *clock);
		auto p = gst_message_new_new_clock((src is null) ? null : src.getObjectGstStruct(), (clock is null) ? null : clock.getClockStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_new_clock");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new segment done message. This message is posted by elements that
	 * finish playback of a segment as a result of a segment seek. This message
	 * is received by the application after all elements that posted a segment_start
	 * have posted the segment_done.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 *  format = The format of the position being done
	 *  position = The position of the segment being done
	 * Returns:
	 *  The new segment done message.
	 */
	public static Message newSegmentDone(ObjectGst src, GstFormat format, long position)
	{
		// GstMessage* gst_message_new_segment_done (GstObject *src,  GstFormat format,  gint64 position);
		auto p = gst_message_new_segment_done((src is null) ? null : src.getObjectGstStruct(), format, position);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_segment_done");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new segment message. This message is posted by elements that
	 * start playback of a segment as a result of a segment seek. This message
	 * is not received by the application but is used for maintenance reasons in
	 * container elements.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 *  format = The format of the position being played
	 *  position = The position of the segment being played
	 * Returns:
	 *  The new segment start message.
	 */
	public static Message newSegmentStart(ObjectGst src, GstFormat format, long position)
	{
		// GstMessage* gst_message_new_segment_start (GstObject *src,  GstFormat format,  gint64 position);
		auto p = gst_message_new_segment_start((src is null) ? null : src.getObjectGstStruct(), format, position);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_segment_start");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new warning message. The message will make copies of error and
	 * debug.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 *  error = The GError for this message.
	 *  debug = A debugging string for something or other.
	 * Returns:
	 *  The new warning message.
	 */
	public static Message newWarning(ObjectGst src, ErrorG error, string dbug)
	{
		// GstMessage* gst_message_new_warning (GstObject *src,  GError *error,  gchar *debug);
		auto p = gst_message_new_warning((src is null) ? null : src.getObjectGstStruct(), (error is null) ? null : error.getErrorGStruct(), Str.toStringz(dbug));

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_warning");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a state dirty message. This message is posted whenever an element
	 * changed its state asynchronously and is used internally to update the
	 * states of container objects.
	 * MT safe.
	 * Params:
	 *  src = the object originating the message
	 * Returns:
	 *  The new state dirty message.
	 */
	public static Message newStateDirty(ObjectGst src)
	{
		// GstMessage* gst_message_new_state_dirty (GstObject *src);
		auto p = gst_message_new_state_dirty((src is null) ? null : src.getObjectGstStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_state_dirty");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new eos message. This message is generated and posted in
	 * the sink elements of a GstBin. The bin will only forward the EOS
	 * message to the application if all sinks have posted an EOS message.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 * Returns:
	 *  The new eos message.
	 */
	public static Message newEOS(ObjectGst src)
	{
		// GstMessage* gst_message_new_eos (GstObject *src);
		auto p = gst_message_new_eos((src is null) ? null : src.getObjectGstStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_eos");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new error message. The message will copy error and
	 * debug. This message is posted by element when a fatal event
	 * occured. The pipeline will probably (partially) stop. The application
	 * receiving this message should stop the pipeline.
	 * MT safe.
	 * Params:
	 *  src = The object originating the message.
	 *  error = The GError for this message.
	 *  debug = A debugging string for something or other.
	 * Returns:
	 *  The new error message.
	 */
	public static Message newError(ObjectGst src, ErrorG error, string dbug)
	{
		// GstMessage* gst_message_new_error (GstObject *src,  GError *error,  gchar *debug);
		auto p = gst_message_new_error((src is null) ? null : src.getObjectGstStruct(), (error is null) ? null : error.getErrorGStruct(), Str.toStringz(dbug));

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_error");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new info message. The message will make copies of error and
	 * debug.
	 * MT safe.
	 * Since 0.10.12
	 * Params:
	 *  src = The object originating the message.
	 *  error = The GError for this message.
	 *  debug = A debugging string for something or other.
	 * Returns:
	 *  The new info message.
	 */
	public static Message newInfo(ObjectGst src, ErrorG error, string dbug)
	{
		// GstMessage* gst_message_new_info (GstObject *src,  GError *error,  gchar *debug);
		auto p = gst_message_new_info((src is null) ? null : src.getObjectGstStruct(), (error is null) ? null : error.getErrorGStruct(), Str.toStringz(dbug));

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_info");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * This message can be posted by elements when their latency requirements
	 * have changed.
	 * Params:
	 *     src = The object originating the message.
	 * Returns:
	 * The new latency message. MT safe.
	 */
	public static Message newLatency(ObjectGst src)
	{
		// GstMessage* gst_message_new_latency (GstObject *src);
		auto p = gst_message_new_latency((src is null) ? null : src.getObjectGstStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_latency");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * Create a new duration changed message. This message is posted by elements
	 * that know the duration of a stream when the duration changes. This message
	 * is received by bins and is used to calculate the total duration of a
	 * pipeline. Elements may post a duration message with a duration of
	 * GST_CLOCK_TIME_NONE to indicate that the duration has changed and the
	 * cached duration should be discarded. The new duration can then be
	 * retrieved via a query.
	 * Params:
	 *    src = The object originating the message. [transfer none]
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static Message newDurationChanged(ObjectGst src)
	{
		// GstMessage * gst_message_new_duration_changed (GstObject *src);
		auto p = gst_message_new_duration_changed((src is null) ? null : src.getObjectGstStruct());

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_duration_changed((src is null) ? null : src.getObjectGstStruct())");
		}

		return new Message(cast(GstMessage*)p );
	}

	/**
	 * This message is posted by elements when they start an ASYNC state change.
	 * Params:
	 * src = The object originating the message. [transfer none]
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static Message newAsyncStart(ObjectGst src)
	{
		// GstMessage * gst_message_new_async_start (GstObject *src);
		auto p = gst_message_new_async_start((src is null) ? null : src.getObjectGstStruct());
		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_async_start((src is null) ? null : src.getObjectGstStruct())");
		}
		return new Message(cast(GstMessage*)p );
	}

	/**
	 * The message is posted when elements completed an ASYNC state change.
	 * running_time contains the time of the desired running_time when this
	 * elements goes to PLAYING. A value of GST_CLOCK_TIME_NONE for running_time
	 * means that the element has no clock interaction and thus doesn't care about
	 * the running_time of the pipeline.
	 * Params:
	 * src = The object originating the message. [transfer none]
	 * runningTime = the desired running_time
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static Message newAsyncDone(ObjectGst src, GstClockTime runningTime)
	{
		// GstMessage * gst_message_new_async_done (GstObject *src,  GstClockTime running_time);
		auto p = gst_message_new_async_done((src is null) ? null : src.getObjectGstStruct(), runningTime);
		if(p is null)
		{
			throw new ConstructionException("null returned by gst_message_new_async_done((src is null) ? null : src.getObjectGstStruct(), runningTime)");
		}
		return new Message(cast(GstMessage*)p );
	}
code: end
outFile: Message

file: gstreamer-GstMeta.html
class: Meta
prefix: gst_meta_
import: glib.Str
array: gst_meta_api_type_register tags
outFile: Meta

file: gstreamer-GstMiniObject.html
struct: GstMiniObject
nostruct: GstMiniObject
class: MiniObject
prefix: gst_mini_object_
structWrap: GstMiniObject* MiniObject
inout: gst_mini_object_replace olddata
outFile: MiniObject

file: GstObject.html
struct: GstObject
class: ObjectGst
prefix: gst_object_
nostruct: GstObjectClass
import: glib.Str
import: glib.ErrorG
import: glib.ListG
import: gobject.ObjectG
import: gobject.ParamSpec
import: gobject.Value
import: gstreamer.ControlBinding
structWrap: GError* ErrorG
structWrap: GList* ListG
structWrap: GObject* ObjectG
structWrap: GParamSpec* ParamSpec
structWrap: GValue* Value
structWrap: GstControlBinding* ControlBinding
structWrap: GstObject* ObjectGst

array: gst_object_default_deep_notify excluded_props
inout: gst_object_default_error debug
inout: gst_object_replace oldobj
array: gst_object_get_value_array values n_values
outFile: ObjectGst

file: GstPad.html
struct: GstPad
class: Pad
prefix: gst_pad_
import: glib.Str
import: gstreamer.Buffer
import: gstreamer.BufferList
import: gstreamer.Caps
import: gstreamer.Element
import: gstreamer.Event
import: gstreamer.Iterator
import: gstreamer.ObjectGst
import: gstreamer.PadTemplate
import: gstreamer.Query
structWrap: GstBuffer* Buffer
structWrap: GstBufferList* BufferList
structWrap: GstCaps* Caps
structWrap: GstElement* Element
structWrap: GstEvent* Event
structWrap: GstIterator* Iterator
structWrap: GstObject* ObjectGst
structWrap: GstPad* Pad
structWrap: GstPadTemplate* PadTemplate
structWrap: GstQuery* Query

inout: gst_pad_get_range buffer
inout: gst_pad_pull_range buffer
out: gst_pad_query_position cur
out: gst_pad_query_duration duration
out: gst_pad_query_convert dest_val
out: gst_pad_peer_query_position cur
out: gst_pad_peer_query_duration duration
out: gst_pad_peer_query_convert dest_val

code: start
	/**
	 * Sets our main struct and passes it to the parent class.
	 * This one is additional to make gstreamer.Element addOnPadAdded()
	 * working without changes.
	 */
	public this (GObject* gstPad)
	{
		super(cast(GstObject*)gstPad);
		this.gstPad = cast(GstPad*) gstPad;
	}
	
	/**
	 * Queries a pad for the stream position.
	 * This is a convenience function for gstreamerD.
	 * Returns:
	 *  The current position in nanoseconds - GstFormat.TIME.
	 */
	public long queryPosition()
	{
		long cur_pos;
		queryPosition( GstFormat.TIME, cur_pos );
		return cur_pos;
	}

	/**
	 * Queries a pad for the stream duration.
	 * This is a convenience function for gstreamerD.
	 * Returns:
	 *  The duration in nanoseconds - GstFormat.TIME.
	 */
	public long queryDuration()
	{
		long cur_dur;
		queryDuration( GstFormat.TIME, cur_dur );
		return cur_dur;
	}
code: end
outFile: Pad

#########for pad signals disconnecting add this with hand editing:
#########also this would be needed on all
#########gtkD signals.
#########
#	protected uint padAddedHandlerId;
#	void delegate(Pad, Element)[] onPadAddedListeners;
#	void addOnPadAdded(void delegate(Pad, Element) dlg)
#	{
#		if ( !("pad-added" in connectedSignals) )
#		{
#			padAddedHandlerId = Signals.connectData(
#			getStruct(),
#			"pad-added",
#			cast(GCallback)&callBackPadAdded,
#			cast(void*)this,
#			null,
#			cast(ConnectFlags)0);
#			connectedSignals["pad-added"] = 1;
#		}
#		onPadAddedListeners ~= dlg;
#	}
#	extern(C) static void callBackPadAdded(GstElement* gstelementStruct, GObject* newPad, Element element)
#	{
#		bit consumed = false;
#		
#		foreach ( void delegate(Pad, Element) dlg ; element.onPadAddedListeners )
#		{
#			dlg(new Pad(newPad), element);
#		}
#		
#		return consumed;
#	}
#	void disconnectOnPadAdded()
#	{
#		if( "pad-added" in connectedSignals )
#		{
#			Signals.handlerDisconnect( getStruct(), padAddedHandlerId );
#			padAddedHandlerId = 0;
#			connectedSignals["pad-added"] = 0;
#			onPadAddedListeners = null;
#		}
#	}

file: GstPadTemplate.html
struct: GstPadTemplate
class: PadTemplate
prefix: gst_pad_template_
prefix: gst_
import: glib.Str
import: gstreamer.Caps
structWrap: GstCaps* Caps
structWrap: GstPadTemplate* PadTemplate
outFile: PadTemplate

file: gstreamer-GstParamSpec.html
struct: GstParamSpecFraction
class: ParamSpecFraction
prefix: gst_param_spec_fraction_
import: glib.Str

nocode: gst_param_spec_fraction

code: start
	/**
	 * This function creates a fraction GParamSpec for use by objects/elements
	 * that want to expose properties of fraction type. This function is typically
	 * used in connection with g_object_class_install_property() in a GObjects's
	 * instance_init function.
	 * Params:
	 * name = canonical name of the property specified
	 * nick = nick name for the property specified
	 * blurb = description of the property specified
	 * minNum = minimum value (fraction numerator)
	 * minDenom = minimum value (fraction denominator)
	 * maxNum = maximum value (fraction numerator)
	 * maxDenom = maximum value (fraction denominator)
	 * defaultNum = default value (fraction numerator)
	 * defaultDenom = default value (fraction denominator)
	 * flags = flags for the property specified
	 * Returns: a newly created parameter specification. [transfer full]
	 */
	public this(string name, string nick, string blurb, int minNum, int minDenom, int maxNum, int maxDenom, int defaultNum, int defaultDenom, GParamFlags flags)
	{
		// GParamSpec * gst_param_spec_fraction (const gchar *name,  const gchar *nick,  const gchar *blurb,  gint min_num,  gint min_denom,  gint max_num,  gint max_denom,  gint default_num,  gint default_denom,  GParamFlags flags);
		auto p = gst_param_spec_fraction(Str.toStringz(name), Str.toStringz(nick), Str.toStringz(blurb), minNum, minDenom, maxNum, maxDenom, defaultNum, defaultDenom, flags);
		if(p is null)
		{
			throw new ConstructionException("null returned by gst_param_spec_fraction");
		}
		this(cast(GstParamSpecFraction*) p);
	}
code: end
outFile: ParamSpecFraction

file: gstreamer-GstParse.html
class: Parse
prefix: gst_parse_
noprefix: gst_parse_context_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gstreamer.Element
import: gstreamer.ParseContext
structWrap: GstElement* Element
structWrap: GstParseContext* ParseContext

array: gst_parse_launchv argv
array: gst_parse_launchv_full argv
outFile: Parse

struct: GstParseContext
class: ParseContext
prefix: gst_parse_context_
strictPrefix: Y
import: glib.Str
outFile: ParseContext

file: GstPipeline.html
struct: GstPipeline
ctorStruct: GstElement
class: Pipeline
prefix: gst_pipeline_
override: getBus
override: setClock
override: getClock
import: glib.Str
import: gstreamer.Bus
import: gstreamer.Clock
structWrap: GstBus* Bus
structWrap: GstClock* Clock
outFile: Pipeline

file: GstPlugin.html
struct: GstPlugin
class: Plugin
prefix: gst_plugin_
override: getName
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: glib.ListG
import: gstreamer.Structure
structWrap: GList* ListG
structWrap: GstPlugin* Plugin
structWrap: GstStructure* Structure

array: gst_plugin_add_dependency env_vars
array: gst_plugin_add_dependency paths
array: gst_plugin_add_dependency names
array: gst_plugin_add_dependency_simple env_vars
array: gst_plugin_add_dependency_simple paths
array: gst_plugin_add_dependency_simple names
outFile: Plugin

file: GstPluginFeature.html
struct: GstPluginFeature
class: PluginFeature
prefix: gst_plugin_feature_
override: getName
alias: setName setFeatureName
import: glib.Str
import: glib.ListG
import: gstreamer.Plugin
structWrap: GList* ListG
structWrap: GstPlugin* Plugin
structWrap: GstPluginFeature* PluginFeature
outFile: PluginFeature

file: gstreamer-GstPoll.html
struct: GstPoll
class: Poll
prefix: gst_poll_
outFile: Poll

file: GstPreset.html
struct: GstPreset
class: PresetT
template: TStruct
prefix: gst_preset_
import: glib.Str
out: gst_preset_get_meta value
interface: PresetIF
outFile: PresetT

file: gstreamer-GstQuery.html
struct: GstQuery
class: Query
prefix: gst_query_
import: glib.Str
import: gstreamer.Allocator
import: gstreamer.BufferPool
import: gstreamer.Caps
import: gstreamer.Structure
structWrap: GstAllocator* Allocator
structWrap: GstBufferPool* BufferPool
structWrap: GstCaps* Caps
structWrap: GstQuery* Query
structWrap: GstStructure* Structure

inout: gst_query_replace old_query
inout: gst_query_parse_convert src_format
inout: gst_query_parse_convert src_value
inout: gst_query_parse_convert dest_format
inout: gst_query_parse_convert dest_value
inout: gst_query_parse_position format
inout: gst_query_parse_position cur
inout: gst_query_parse_duration format
inout: gst_query_parse_duration duration
inout: gst_query_parse_latency live
inout: gst_query_parse_latency min_latency
inout: gst_query_parse_latency max_latency
inout: gst_query_parse_seeking format
inout: gst_query_parse_seeking seekable
inout: gst_query_parse_seeking segment_start
inout: gst_query_parse_seeking segment_end
array: gst_query_set_formatsv formats n_formats
out: gst_query_parse_n_formats n_formats
out: gst_query_parse_nth_format format
inout: gst_query_parse_segment rate
inout: gst_query_parse_segment format
inout: gst_query_parse_segment start_value
inout: gst_query_parse_segment stop_value
out: gst_query_parse_caps filter
out: gst_query_parse_caps_result caps
out: gst_query_parse_accept_caps caps
out: gst_query_parse_accept_caps_result result
out: gst_query_parse_buffering_percent busy
out: gst_query_parse_buffering_percent percent
out: gst_query_parse_buffering_stats mode
out: gst_query_parse_buffering_stats avg_in
out: gst_query_parse_buffering_stats avg_out
out: gst_query_parse_buffering_stats buffering_left
out: gst_query_parse_buffering_range format
out: gst_query_parse_buffering_range start
out: gst_query_parse_buffering_range stop
out: gst_query_parse_buffering_range estimated_total
out: gst_query_parse_nth_buffering_range start
out: gst_query_parse_nth_buffering_range stop
out: gst_query_parse_uri uri
out: gst_query_parse_allocation caps
out: gst_query_parse_allocation need_pool
out: gst_query_parse_nth_allocation_pool pool
out: gst_query_parse_nth_allocation_pool size
out: gst_query_parse_nth_allocation_pool min_buffers
out: gst_query_parse_nth_allocation_pool max_buffers
out: gst_query_parse_nth_allocation_param allocator
out: gst_query_parse_nth_allocation_param params
out: gst_query_set_nth_allocation_param allocator
out: gst_query_set_nth_allocation_param params
out: gst_query_parse_nth_allocation_meta params
out: gst_query_find_allocation_meta index
out: gst_query_parse_scheduling flags
out: gst_query_parse_scheduling minsize
out: gst_query_parse_scheduling maxsize
out: gst_query_parse_scheduling align

nocode: gst_query_new_position
code: start
	/**
	 * Constructs a new query stream position query object. Use gst_query_unref()
	 * when done with it. A position query is used to query the current position
	 * of playback in the streams, in some format.
	 * Params:
	 *  format = the default GstFormat for the new query
	 * Returns:
	 *  A GstQuery
	 */
	public static Query newPosition(GstFormat format)
	{
		// GstQuery* gst_query_new_position (GstFormat format);
		auto p = gst_query_new_position(format);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_position");
		}

		return new Query( cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_duration
code: start
	/**
	 * Constructs a new stream duration query object to query in the given format.
	 * Use gst_query_unref() when done with it. A duration query will give the
	 * total length of the stream.
	 * Params:
	 *  format = the GstFormat for this duration query
	 * Returns:
	 *  A GstQuery
	 */
	public static Query newDuration(GstFormat format)
	{
		// GstQuery* gst_query_new_duration (GstFormat format);
		auto p = gst_query_new_duration(format);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_duration");
		}

		return new Query( cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_seeking
code: start
	/**
	 * Constructs a new query object for querying seeking properties of
	 * the stream.
	 * Params:
	 *  format = the default GstFormat for the new query
	 * Returns:
	 *  A GstQuery
	 */
	public static Query newSeeking(GstFormat format)
	{
		// GstQuery* gst_query_new_seeking (GstFormat format);
		auto p = gst_query_new_seeking(format);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_seeking");
		}

		return new Query(cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_formats
code: start
	/**
	 * Constructs a new query object for querying formats of
	 * the stream.
	 * Since 0.10.4
	 * Returns:
	 *  A GstQuery
	 */
	public static Query newFormats()
	{
		// GstQuery* gst_query_new_formats (void);
		auto p = gst_query_new_formats();

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_formats");
		}

		return new Query(cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_segment
code: start
	/**
	 * Constructs a new segment query object. Use gst_query_unref()
	 * when done with it. A segment query is used to discover information about the
	 * currently configured segment for playback.
	 * Params:
	 *  format = the GstFormat for the new query
	 * Returns:
	 *  a GstQuery
	 */
	public static Query newSegment(GstFormat format)
	{
		// GstQuery* gst_query_new_segment (GstFormat format);
		auto p = gst_query_new_segment(format);

		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_segment");
		}

		return new Query(cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_latency
code: start
	/**
	 * Constructs a new latency query object.
	 * Use gst_query_unref() when done with it. A latency query is usually performed
	 * by sinks to compensate for additional latency introduced by elements in the
	 * pipeline.
	 * Free-function: gst_query_unref
	 */
	public static Query newLatency()
	{
		// GstQuery * gst_query_new_latency (void);
		auto p = gst_query_new_latency();
		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_latency()");
		}
		return new Query(cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_uri
code: start
	/**
	 * Constructs a new query URI query object. Use gst_query_unref()
	 * when done with it. An URI query is used to query the current URI
	 * that is used by the source or sink.
	 * Free-function: gst_query_unref
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static Query newUri()
	{
		// GstQuery * gst_query_new_uri (void);
		auto p = gst_query_new_uri();
		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_uri()");
		}
		return new Query(cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_scheduling
code: start
	/**
	 * Constructs a new query object for querying the scheduling properties.
	 * Free-function: gst_query_unref
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static Query newScheduling()
	{
		// GstQuery * gst_query_new_scheduling (void);
		auto p = gst_query_new_scheduling();
		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_scheduling()");
		}
		return new Query(cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_drain
code: start
	/**
	 * Constructs a new query object for querying the drain state.
	 * Free-function: gst_query_unref
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static Query newDrain()
	{
		// GstQuery * gst_query_new_drain (void);
		auto p = gst_query_new_drain();
		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_drain()");
		}
		return new Query(cast(GstQuery*)p );
	}
code: end
nocode: gst_query_new_accept_caps
code: start
	/**
	 * Constructs a new query object for querying if caps are accepted.
	 * Free-function: gst_query_unref
	 * Params:
	 * caps = a fixed GstCaps
	 * Throws: ConstructionException GTK+ fails to create the object.
	 */
	public static Query newAcceptCaps(Caps caps)
	{
		// GstQuery * gst_query_new_accept_caps (GstCaps *caps);
		auto p = gst_query_new_accept_caps((caps is null) ? null : caps.getCapsStruct());
		if(p is null)
		{
			throw new ConstructionException("null returned by gst_query_new_accept_caps((caps is null) ? null : caps.getCapsStruct())");
		}
		return new Query(cast(GstQuery*)p );
	}
code: end
outFile: Query

file: GstRegistry.html
struct: GstRegistry
class: Registry
prefix: gst_registry_
import: glib.Str
import: glib.ListG
import: gstreamer.Plugin
import: gstreamer.PluginFeature
structWrap: GList* ListG
structWrap: GstRegistry* Registry
structWrap: GstPlugin* Plugin
structWrap: GstPluginFeature* PluginFeature
outFile: Registry

file: gstreamer-GstSegment.html
struct: GstSegment
class: Segment
prefix: gst_segment_
structWrap: GstSegment* Segment

inout: gst_segment_clip clip_start
inout: gst_segment_clip clip_stop
inout: gst_segment_do_seek update
outFile: Segment

file: gstreamer-GstStructure.html
struct: GstStructure
class: Structure
prefix: gst_structure_
override: toString
import: glib.Str
import: glib.Date
import: gobject.Value
import: gstreamer.DateTime
structWrap: GDate* Date
structWrap: GValue* Value
structWrap: GstDateTime* DateTime
structWrap: GstStructure* Structure

out: gst_structure_get_boolean value
out: gst_structure_get_int value
out: gst_structure_get_uint value
out: gst_structure_get_double value
out: gst_structure_get_date value
out: gst_structure_get_date_time value
out: gst_structure_get_clock_time value
out: gst_structure_get_enum value
out: gst_structure_get_fraction value_numerator
out: gst_structure_get_fraction value_denominator
out: gst_structure_from_string end
outFile: Structure

file: GstSystemClock.html
struct: GstSystemClock
class: SystemClock
prefix: gst_system_clock_
import: gstreamer.Clock
structWrap: GstClock* Clock
outFile: SystemClock

file: gstreamer-GstTagList.html
struct: GstTagList
class: TagList
prefix: gst_tag_list_
prefix: gst_tag_
override:toString
import: glib.Str
import: glib.Date
import: gobject.Value
import: gstreamer.DateTime
import: gstreamer.Sample
structWrap: GDate* Date
structWrap: GValue* Value
structWrap: GstDateTime* DateTime
structWrap: GstSample* Sample
structWrap: GstTagList* TagList

out: gst_tag_list_get_boolean value
out: gst_tag_list_get_boolean_index value
out: gst_tag_list_get_int value
out: gst_tag_list_get_int_index value
out: gst_tag_list_get_uint value
out: gst_tag_list_get_uint_index value
out: gst_tag_list_get_int64 value
out: gst_tag_list_get_int64_index value
out: gst_tag_list_get_uint64 value
out: gst_tag_list_get_uint64_index value
out: gst_tag_list_get_float value
out: gst_tag_list_get_float_index value
out: gst_tag_list_get_double value
out: gst_tag_list_get_double_index value
out: gst_tag_list_get_string value
out: gst_tag_list_get_string_index value
out: gst_tag_list_peek_string_index value
out: gst_tag_list_get_pointer value
out: gst_tag_list_get_pointer_index value
out: gst_tag_list_get_date value
out: gst_tag_list_get_date_index value
out: gst_tag_list_get_date_time value
out: gst_tag_list_get_date_time_index value
out: gst_tag_list_get_sample sample
out: gst_tag_list_get_sample_index sample
outFile: TagList

file: GstTagSetter.html
struct: GstTagSetter
class: TagSetterT
template: TStruct
prefix: gst_tag_setter_
import: glib.Str
import: gobject.Value
import: gstreamer.TagList
structWrap: GValue* Value
structWrap: GstTagList* TagList
interface: TagSetterIF
outFile: TagSetterT

file: GstTask.html
struct: GstTask
class: Task
prefix: gst_task_
import: glib.Str
import: gthread.RecMutex
import: gthread.Thread
import: gstreamer.TaskPool
structWrap: GRecMutex* RecMutex
structWrap: GThread* Thread
structWrap: GstTaskPool* TaskPool
outFile: Task

file: GstTaskPool.html
struct: GstTaskPool
class: TaskPool
prefix: gst_task_pool_
import: glib.ErrorG
import: glib.GException
outFile: TaskPool

file: gstreamer-GstToc.html
struct: GstToc
class: Toc
prefix: gst_toc_
noprefix: gst_toc_entry_
import: glib.Str
import: glib.ListG
import: gstreamer.TagList
import: gstreamer.TocEntry
structWrap: GList* ListG
structWrap: GstTagList* TagList
structWrap: GstTocEntry* TocEntry
outFile: Toc

struct: GstTocEntry
class: TocEntry
prefix: gst_toc_entry_
strictPrefix: Y
import: glib.Str
import: glib.ListG
import: gstreamer.TagList
import: gstreamer.Toc
structWrap: GList* ListG
structWrap: GstTagList* TagList
structWrap: GstToc* Toc
structWrap: GstTocEntry* TocEntry

out: gst_toc_entry_get_start_stop_times start
out: gst_toc_entry_get_start_stop_times stop
outFile: TocEntry

file: gstreamer-GstTocSetter.html
struct: GstTocSetter
class: TocSetterT
template: TStruct
prefix: gst_toc_setter_
import: gstreamer.Toc
structWrap: GstToc* Toc
interface: TocSetterIF
outFile: TocSetterT

file: gstreamer-GstTypeFind.html
struct: GstTypeFind
class: TypeFind
prefix: gst_type_find_
import: glib.Str
import: gstreamer.Caps
import: gstreamer.Plugin
structWrap: GstCaps* Caps
structWrap: GstPlugin* Plugin

array: gst_type_find_register extensions

nocode: gst_type_find_peek

code: start
	/**
	 * Returns the size bytes of the stream to identify beginning at offset. If
	 * offset is a positive number, the offset is relative to the beginning of the
	 * stream, if offset is a negative number the offset is relative to the end of
	 * the stream. The returned memory is valid until the typefinding function
	 * returns and must not be freed.
	 * Params:
	 * offset = The offset
	 * size = The number of bytes to return
	 * Returns: the requested data, or NULL if that data is not available.
	 */
	public ubyte[] peek(long offset, uint size)
	{
		// guint8* gst_type_find_peek (GstTypeFind *find,  gint64 offset,  guint size);
		ubyte* buff = gst_type_find_peek(gstTypeFind, offset, size);

		return buff[0 .. size];
	}
code: end
outFile: TypeFind

file: GstTypeFindFactory.html
struct: GstTypeFindFactory
class: TypeFindFactory
prefix: gst_type_find_factory_
import: glib.Str
import: glib.ListG
import: gstreamer.Caps
import: gstreamer.TypeFind
structWrap: GList* ListG
structWrap: GstCaps* Caps
structWrap: GstTypeFind* TypeFind
outFile: TypeFindFactory

file: gstreamer-GstUriHandler.html
struct: GstURIHandler
class: UriHandlerT
template: TStruct
prefix: gst_uri_protocol_
import: glib.Str
import: glib.ErrorG
import: glib.GException
import: gstreamer.Element
structWrap: GstElement* Element
interface: UriHandlerIF
outFile: UriHandlerT

file: gstreamer-GstUtils.html
class: Utils
prefix: gst_util_
import: glib.Str
import: gobject.ObjectG
import: gobject.Value
structWrap: GObject* ObjectG
structWrap: GValue* Value

out: gst_util_fraction_to_double dest
out: gst_util_double_to_fraction dest_n
out: gst_util_double_to_fraction dest_d
out: gst_util_fraction_multiply res_n
out: gst_util_fraction_multiply res_d
out: gst_util_fraction_add res_n
out: gst_util_fraction_add res_d
outFile: Utils

file: gstreamer-GstValue.html
class: ValueGst
prefix: gst_value_
import: glib.Str
import: gobject.Value
import: gstreamer.Caps
import: gstreamer.Structure
structWrap: GValue* Value
structWrap: GstCaps* Caps
structWrap: GstStructure* Structure
inout: gst_value_register table
outFile: Value

